{"version":3,"sources":["lib/layout/src/List/methods.js","lib/layout/src/Arranger/Arranger.js","lib/layout/src/CarouselArranger.js","lib/layout/src/CardArranger.js","lib/layout/src/CollapsingArranger.js","lib/layout/src/Panels/Panels.js","lib/layout/src/FittableLayout/FittableLayout.js","lib/layout/src/FlyweightRepeater.js","lib/layout/src/FittableColumns.js","lib/layout/src/FittableRows.js","lib/layout/src/List/List.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACliEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACv6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"generated.js","sourceRoot":"","sourcesContent":["var\n\tanimation = require('enyo/animation'),\n\tdom = require('enyo/dom'),\n\tkind = require('enyo/kind'),\n\tlogger = require('enyo/logger'),\n\tplatform = require('enyo/platform'),\n\tutils = require('enyo/utils');\n\n/**\n* layout/List was too large for the parser so we have to split it up. For now, we're arbitrarily\n* splitting the methods into another file. A more appropriate refactoring is required.\n* @module layout/List\n* @private\n*/\n\nmodule.exports = /** @lends module:layout/List~List.prototype */ {\n\t/**\n\t* @method\n\t* @private\n\t*/\n\timportProps: kind.inherit(function (sup) {\n\t\treturn function (props) {\n\t\t\t// force touch on desktop when we have reorderable items to work around\n\t\t\t// problems with native scroller\n\t\t\tif (props && props.reorderable) {\n\t\t\t\tthis.touch = true;\n\t\t\t}\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tcreate: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tthis.pageSizes = [];\n\t\t\tthis.orientV = this.orient == 'v';\n\t\t\tthis.vertical = this.orientV ? 'default' : 'hidden';\n\t\t\tsup.apply(this, arguments);\n\t\t\tthis.$.generator.orient = this.orient;\n\t\t\tthis.getStrategy().translateOptimized = true;\n\t\t\tthis.$.port.addRemoveClass('horizontal',!this.orientV);\n\t\t\tthis.$.port.addRemoveClass('vertical',this.orientV);\n\t\t\tthis.$.page0.addRemoveClass('vertical',this.orientV);\n\t\t\tthis.$.page1.addRemoveClass('vertical',this.orientV);\n\t\t\tthis.bottomUpChanged();  // Initializes pageBound also\n\t\t\tthis.noSelectChanged();\n\t\t\tthis.multiSelectChanged();\n\t\t\tthis.toggleSelectedChanged();\n\t\t\t// setup generator to default to 'full-list' values\n\t\t\tthis.$.generator.setRowOffset(0);\n\t\t\tthis.$.generator.setCount(this.count);\n\t\t};\n\t}),\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tinitComponents: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tthis.createReorderTools();\n\t\t\tsup.apply(this, arguments);\n\t\t\tthis.createSwipeableComponents();\n\t\t};\n\t}),\n\n\t/**\n\t* @private\n\t*/\n\tcreateReorderTools: function () {\n\t\tthis.createComponent({\n\t\t\tname: 'reorderContainer',\n\t\t\tclasses: 'enyo-list-reorder-container',\n\t\t\tondown: 'sendToStrategy',\n\t\t\tondrag: 'sendToStrategy',\n\t\t\tondragstart: 'sendToStrategy',\n\t\t\tondragfinish: 'sendToStrategy',\n\t\t\tonflick: 'sendToStrategy'\n\t\t});\n\t},\n\n\t/**\n\t* Adjusts the parent control so [listTools]{@link module:layout/List~List#listTools} are\n\t* created inside the strategy. This is necessary for strategies like\n\t* {@link module:enyo/TouchScrollStrategy~TouchScrollStrategy}, which wrap their contents with\n\t* additional DOM nodes.\n\t*\n\t* @see {@link module:enyo/Scroller~Scroller#createStrategy}\n\t* @method\n\t* @private\n\t*/\n\tcreateStrategy: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tthis.controlParentName = 'strategy';\n\t\t\tsup.apply(this, arguments);\n\t\t\tthis.createChrome(this.listTools);\n\t\t\tthis.controlParentName = 'client';\n\t\t\tthis.discoverControlParent();\n\t\t};\n\t}),\n\n\t/**\n\t* @private\n\t*/\n\tcreateSwipeableComponents: function () {\n\t\tfor (var i=0;i<this.swipeableComponents.length;i++) {\n\t\t\tthis.$.swipeableComponents.createComponent(this.swipeableComponents[i], {owner: this.owner});\n\t\t}\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\trendered: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tsup.apply(this, arguments);\n\t\t\tthis.$.generator.node = this.$.port.hasNode();\n\t\t\tthis.$.generator.generated = true;\n\t\t\tthis.reset();\n\t\t};\n\t}),\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\thandleResize: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tsup.apply(this, arguments);\n\t\t\tthis.refresh();\n\t\t};\n\t}),\n\n\t/**\n\t* @private\n\t*/\n\tbottomUpChanged: function () {\n\t\tthis.$.generator.bottomUp = this.bottomUp;\n\t\tthis.$.page0.applyStyle(this.pageBound, null);\n\t\tthis.$.page1.applyStyle(this.pageBound, null);\n\n\t\tif (this.orientV) {\n\t\t\tthis.pageBound = this.bottomUp ? 'bottom' : 'top';\n\t\t} else {\n\t\t\tif (this.rtl) {\n\t\t\t\tthis.pageBound = this.bottomUp ? 'left' : 'right';\n\t\t\t} else {\n\t\t\t\tthis.pageBound = this.bottomUp ? 'right' : 'left';\n\t\t\t}\n\t\t}\n\n\t\tif (!this.orientV && this.bottomUp){\n\t\t\tthis.$.page0.applyStyle('left', 'auto');\n\t\t\tthis.$.page1.applyStyle('left', 'auto');\n\t\t}\n\n\t\tif (this.hasNode()) {\n\t\t\tthis.reset();\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tnoSelectChanged: function () {\n\t\tthis.$.generator.setNoSelect(this.noSelect);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tmultiSelectChanged: function () {\n\t\tthis.$.generator.setMultiSelect(this.multiSelect);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\ttoggleSelectedChanged: function () {\n\t\tthis.$.generator.setToggleSelected(this.toggleSelected);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tcountChanged: function () {\n\t\tif (this.hasNode()) {\n\t\t\tthis.updateMetrics();\n\t\t}\n\t},\n\n\t/**\n\t* Re-dispatches events from the reorder tools to the scroll strategy.\n\t*\n\t* @private\n\t*/\n\tsendToStrategy: function (sender, event) {\n\t\tthis.$.strategy.dispatchEvent('on' + event.type, event, sender);\n\t},\n\n\t/**\n\t* Calculates page metrics (size, number of pages) and resizes the port.\n\t*\n\t* @private\n\t*/\n\tupdateMetrics: function () {\n\t\tthis.defaultPageSize = this.rowsPerPage * (this.rowSize || 100);\n\t\tthis.pageCount = Math.ceil(this.count / this.rowsPerPage);\n\t\tthis.portSize = 0;\n\t\tfor (var i=0; i < this.pageCount; i++) {\n\t\t\tthis.portSize += this.getPageSize(i);\n\t\t}\n\t\tthis.adjustPortSize();\n\t},\n\n\t/**\n\t* Handles hold pulse events. Used to delay before running hold logic.\n\t*\n\t* @private\n\t*/\n\tholdpulse: function (sender, event) {\n\t\t// don't activate if we're not supporting reordering or if we've already\n\t\t// activated the reorder logic\n\t\tif (!this.getReorderable() || this.isReordering()) {\n\t\t\treturn;\n\t\t}\n\t\t// first pulse event that exceeds our minimum hold time activates\n\t\tif (event.holdTime >= this.reorderHoldTimeMS) {\n\t\t\t// determine if we should handle the hold event\n\t\t\tif (this.shouldStartReordering(sender, event)) {\n\t\t\t\tthis.startReordering(event);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* Handles DragStart events.\n\t*\n\t* @private\n\t*/\n\tdragstart: function (sender, event) {\n\t\t// stop dragstart from propagating if we're in reorder mode\n\t\tif (this.isReordering()) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this.isSwipeable()) {\n\t\t\treturn this.swipeDragStart(sender, event);\n\t\t}\n\t},\n\n\t/**\n\t* Determines whether we should handle the drag event.\n\t*\n\t* @private\n\t*/\n\tdrag: function (sender, event) {\n\t\tif (this.shouldDoReorderDrag(event)) {\n\t\t\tevent.preventDefault();\n\t\t\tthis.reorderDrag(event);\n\t\t\treturn true;\n\t\t} else if (this.isSwipeable()) {\n\t\t\tevent.preventDefault();\n\t\t\tthis.swipeDrag(sender, event);\n\t\t\treturn true;\n\t\t}\n\t},\n\n\t/**\n\t* Handles DragFinish events.\n\t*\n\t* @private\n\t*/\n\tdragfinish: function (sender, event) {\n\t\tif (this.isReordering()) {\n\t\t\tthis.finishReordering(sender, event);\n\t\t} else if (this.isSwipeable()) {\n\t\t\tthis.swipeDragFinish(sender, event);\n\t\t}\n\t},\n\n\t/**\n\t* Handles up events.\n\t*\n\t* @private\n\t*/\n\tup: function (sender, event) {\n\t\tif (this.isReordering()) {\n\t\t\tthis.finishReordering(sender, event);\n\t\t}\n\t},\n\n\t/**\n\t* Calculates the record indices for `pageNumber` and generates the markup\n\t* for that page.\n\t*\n\t* @private\n\t*/\n\tgeneratePage: function (pageNumber, target) {\n\t\tthis.page = pageNumber;\n\t\tvar r = this.rowsPerPage * this.page;\n\t\tthis.$.generator.setRowOffset(r);\n\t\tvar rpp = Math.min(this.count - r, this.rowsPerPage);\n\t\tthis.$.generator.setCount(rpp);\n\t\tvar html = this.$.generator.generateChildHtml();\n\t\ttarget.setContent(html);\n\t\t// prevent reordering row from being draw twice\n\t\tif (this.getReorderable() && this.draggingRowIndex > -1) {\n\t\t\tthis.hideReorderingRow();\n\t\t}\n\t\tvar bounds = target.getBounds();\n\t\tvar pageSize = this.orientV ? bounds.height : bounds.width;\n\t\t// if rowSize is not set, use the height or width from the first generated page\n\t\tif (!this.rowSize && pageSize > 0) {\n\t\t\tthis.rowSize = Math.floor(pageSize / rpp);\n\t\t\tthis.updateMetrics();\n\t\t}\n\t\t// update known page sizes\n\t\tif (!this.fixedSize) {\n\t\t\tvar s0 = this.getPageSize(pageNumber);\n\t\t\tif (s0 != pageSize && pageSize > 0) {\n\t\t\t\tthis.pageSizes[pageNumber] = pageSize;\n\t\t\t\tthis.portSize += pageSize - s0;\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* Maps a row index number to the page number where it would be found.\n\t*\n\t* @private\n\t*/\n\tpageForRow: function (index) {\n\t\treturn Math.floor(index / this.rowsPerPage);\n\t},\n\n\t/**\n\t * Updates the list pages to show the correct rows for the requested `top` position.\n\t *\n\t * @param  {Number} top - Position in pixels from the top.\n\t * @private\n\t */\n\tupdate: function (top) {\n\t\tvar updated = false;\n\t\t// get page info for position\n\t\tvar pi = this.positionToPageInfo(top);\n\t\t// zone line position\n\t\tvar pos = pi.pos + this.scrollerSize/2;\n\t\t// leap-frog zone position\n\t\tvar k = Math.floor(pos/Math.max(pi.size, this.scrollerSize) + 1/2) + pi.no;\n\t\t// which page number for page0 (even number pages)?\n\t\tvar p = (k % 2 === 0) ? k : k-1;\n\t\tif (this.p0 != p && this.isPageInRange(p)) {\n\t\t\tthis.removedInitialPage = this.removedInitialPage || (this.draggingRowPage == this.p0);\n\t\t\tthis.generatePage(p, this.$.page0);\n\t\t\tthis.positionPage(p, this.$.page0);\n\t\t\tthis.p0 = p;\n\t\t\tupdated = true;\n\t\t\tthis.p0RowBounds = this.getPageRowSizes(this.$.page0);\n\t\t}\n\t\t// which page number for page1 (odd number pages)?\n\t\tp = (k % 2 === 0) ? Math.max(1, k-1) : k;\n\t\t// position data page 1\n\t\tif (this.p1 != p && this.isPageInRange(p)) {\n\t\t\tthis.removedInitialPage = this.removedInitialPage || (this.draggingRowPage == this.p1);\n\t\t\tthis.generatePage(p, this.$.page1);\n\t\t\tthis.positionPage(p, this.$.page1);\n\t\t\tthis.p1 = p;\n\t\t\tupdated = true;\n\t\t\tthis.p1RowBounds = this.getPageRowSizes(this.$.page1);\n\t\t}\n\t\tif (updated) {\n\t\t\t// reset generator back to 'full-list' values\n\t\t\tthis.$.generator.setRowOffset(0);\n\t\t\tthis.$.generator.setCount(this.count);\n\t\t\tif (!this.fixedSize) {\n\t\t\t\tthis.adjustBottomPage();\n\t\t\t\tthis.adjustPortSize();\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* Calculates the height and width of each row for a page.\n\t*\n\t* @param {module:enyo/Control~Control} page - Page control.\n\t* @private\n\t*/\n\tgetPageRowSizes: function (page) {\n\t\tvar rows = {};\n\t\tvar allDivs = page.hasNode().querySelectorAll('div[data-enyo-index]');\n\t\tfor (var i=0, index, bounds; i < allDivs.length; i++) {\n\t\t\tindex = allDivs[i].getAttribute('data-enyo-index');\n\t\t\tif (index !== null) {\n\t\t\t\tbounds = dom.getBounds(allDivs[i]);\n\t\t\t\trows[parseInt(index, 10)] = {height: bounds.height, width: bounds.width};\n\t\t\t}\n\t\t}\n\t\treturn rows;\n\t},\n\n\t/**\n\t* Updates row bounds when rows are re-rendered.\n\t*\n\t* @private\n\t*/\n\tupdateRowBounds: function (index) {\n\t\tif (this.p0RowBounds[index]) {\n\t\t\tthis.updateRowBoundsAtIndex(index, this.p0RowBounds, this.$.page0);\n\t\t} else if (this.p1RowBounds[index]) {\n\t\t\tthis.updateRowBoundsAtIndex(index, this.p1RowBounds, this.$.page1);\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tupdateRowBoundsAtIndex: function (index, rows, page) {\n\t\tvar rowDiv = page.hasNode().querySelector('div[data-enyo-index=\"' + index + '\"]');\n\t\tvar bounds = dom.getBounds(rowDiv);\n\t\trows[index].height = bounds.height;\n\t\trows[index].width = bounds.width;\n\t},\n\n\t/**\n\t* Updates the list for the given `position`.\n\t*\n\t* @param {Number} position - Position in pixels.\n\t* @private\n\t*/\n\tupdateForPosition: function (position) {\n\t\tthis.update(this.calcPos(position));\n\t},\n\n\t/**\n\t* Adjusts the position if the list is [bottomUp]{@link module:layout/List~List#bottomUp}.\n\t*\n\t* @param {Number} position - Position in pixels.\n\t* @private\n\t*/\n\tcalcPos: function (position) {\n\t\treturn (this.bottomUp ? (this.portSize - this.scrollerSize - position) : position);\n\t},\n\n\t/**\n\t* Determines which page is on the bottom and positions it appropriately.\n\t*\n\t* @private\n\t*/\n\tadjustBottomPage: function () {\n\t\tvar bp = this.p0 >= this.p1 ? this.$.page0 : this.$.page1;\n\t\tthis.positionPage(bp.pageNo, bp);\n\t},\n\n\t/**\n\t* Updates the size of the port to be the greater of the size of the scroller or\n\t* the `portSize`.\n\t*\n\t* @private\n\t*/\n\tadjustPortSize: function () {\n\t\tthis.scrollerSize = this.orientV ? this.getBounds().height : this.getBounds().width;\n\t\tvar s = Math.max(this.scrollerSize, this.portSize);\n\t\tthis.$.port.applyStyle((this.orientV ? 'height' : 'width'), s + 'px');\n\t\tif (!this.orientV) {\n\t\t\tthis.$.port.applyStyle('height', this.getBounds().height + 'px');\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tpositionPage: function (pageNumber, target) {\n\t\ttarget.pageNo = pageNumber;\n\t\tvar p = this.pageToPosition(pageNumber);\n\t\ttarget.applyStyle(this.pageBound, p + 'px');\n\t},\n\n\t/**\n\t* Calculates the position of `page`.\n\t*\n\t* @param {Number} page - Page number.\n\t* @private\n\t*/\n\tpageToPosition: function (page) {\n\t\tvar p = 0;\n\t\twhile (page > 0) {\n\t\t\tpage--;\n\t\t\tp += this.getPageSize(page);\n\t\t}\n\t\treturn p;\n\t},\n\n\t/**\n\t * Retrieves the metrics for a page covering `position`.\n\t *\n\t * @param  {Number} position - Position in pixels.\n\t * @return {module:layout/List~List~PageInfo}\n\t * @private\n\t */\n\tpositionToPageInfo: function (position) {\n\t\tvar page = -1;\n\t\tvar p = this.calcPos(position);\n\t\tvar s = this.defaultPageSize;\n\t\twhile (p >= 0) {\n\t\t\tpage++;\n\t\t\ts = this.getPageSize(page);\n\t\t\tp -= s;\n\t\t}\n\t\tpage = Math.max(page, 0);\n\t\treturn {\n\t\t\tno: page,\n\t\t\tsize: s,\n\t\t\tpos: p + s,\n\t\t\tstartRow: (page * this.rowsPerPage),\n\t\t\tendRow: Math.min((page + 1) * this.rowsPerPage - 1, this.count - 1)\n\t\t};\n\t},\n\n\t/**\n\t* Determines if `page` is a valid page number.\n\t*\n\t* @param {Number} page - Page number.\n\t* @private\n\t*/\n\tisPageInRange: function (page) {\n\t\treturn page == Math.max(0, Math.min(this.pageCount-1, page));\n\t},\n\n\t/**\n\t* Calculates the size of a page. The size is estimated if the page has not\n\t* yet been rendered.\n\t*\n\t* @private\n\t*/\n\tgetPageSize: function (pageNumber) {\n\t\tvar size = this.pageSizes[pageNumber];\n\t\t// estimate the size based on how many rows are in this page\n\t\tif (!size) {\n\t\t\tvar firstRow = this.rowsPerPage * pageNumber;\n\t\t\tvar numRows = Math.min(this.count - firstRow, this.rowsPerPage);\n\t\t\tsize = this.defaultPageSize * (numRows / this.rowsPerPage);\n\t\t}\n\t\t// can never return size of 0, as that would lead to infinite loops\n\t\treturn Math.max(1, size);\n\t},\n\n\t/**\n\t* Resets pages and removes all rendered rows.\n\t*\n\t* @private\n\t*/\n\tinvalidatePages: function () {\n\t\tthis.p0 = this.p1 = null;\n\t\tthis.p0RowBounds = {};\n\t\tthis.p1RowBounds = {};\n\t\t// clear the html in our render targets\n\t\tthis.$.page0.setContent('');\n\t\tthis.$.page1.setContent('');\n\t},\n\n\t/**\n\t* Resets page and row sizes.\n\t*\n\t* @private\n\t*/\n\tinvalidateMetrics: function () {\n\t\tthis.pageSizes = [];\n\t\tthis.rowSize = 0;\n\t\tthis.updateMetrics();\n\t},\n\n\t/**\n\t* When the list is scrolled, ensures that the correct rows are rendered and\n\t* that the reordering controls are positioned correctly.\n\t*\n\t* @see {@link module:enyo/Scroller~Scroller#scroll}\n\t* @method\n\t* @private\n\t*/\n\tscroll: kind.inherit(function (sup) {\n\t\treturn function (sender, event) {\n\t\t\tvar r = sup.apply(this, arguments);\n\t\t\tvar pos = this.orientV ? this.getScrollTop() : this.getScrollLeft();\n\t\t\tif (this.lastPos === pos) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tthis.lastPos = pos;\n\t\t\tthis.update(pos);\n\t\t\tif (this.pinnedReorderMode) {\n\t\t\t\tthis.reorderScroll(sender, event);\n\t\t\t}\n\t\t\treturn r;\n\t\t};\n\t}),\n\n\t/**\n\t* Updates the list rows when the scroll top is set explicitly.\n\t*\n\t* @see {@link module:enyo/Scroller~Scroller#setScrollTop}\n\t* @method\n\t* @public\n\t*/\n\tsetScrollTop: kind.inherit(function (sup) {\n\t\treturn function (scrollTop) {\n\t\t\tthis.update(scrollTop);\n\t\t\tsup.apply(this, arguments);\n\t\t\tthis.twiddle();\n\t\t};\n\t}),\n\n\t/**\n\t* @private\n\t*/\n\tgetScrollPosition: function () {\n\t\treturn this.calcPos(this[(this.orientV ? 'getScrollTop' : 'getScrollLeft')]());\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tsetScrollPosition: function (position) {\n\t\tthis[(this.orientV ? 'setScrollTop' : 'setScrollLeft')](this.calcPos(position));\n\t},\n\n\t/**\n\t* Scrolls the list so that the last item is visible.\n\t*\n\t* @method\n\t* @public\n\t*/\n\tscrollToBottom: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tthis.update(this.getScrollBounds().maxTop);\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* Scrolls to the specified row.\n\t*\n\t* @param {Number} row - The index of the row to scroll to.\n\t* @public\n\t*/\n\tscrollToRow: function (row) {\n\t\tvar page = this.pageForRow(row);\n\t\tvar h = this.pageToPosition(page);\n\t\t// update the page\n\t\tthis.updateForPosition(h);\n\t\t// call pageToPosition again and this time should return the right pos since the page info is populated\n\t\th = this.pageToPosition(page);\n\t\tthis.setScrollPosition(h);\n\t\tif (page == this.p0 || page == this.p1) {\n\t\t\tvar rowNode = this.$.generator.fetchRowNode(row);\n\t\t\tif (rowNode) {\n\t\t\t\t// calc row offset\n\t\t\t\tvar offset = (this.orientV ? rowNode.offsetTop : rowNode.offsetLeft);\n\t\t\t\tif (this.bottomUp) {\n\t\t\t\t\toffset = this.getPageSize(page) - (this.orientV ? rowNode.offsetHeight : rowNode.offsetWidth) - offset;\n\t\t\t\t}\n\t\t\t\tvar p = this.getScrollPosition() + offset;\n\t\t\t\tthis.setScrollPosition(p);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* Scrolls to the beginning of the list.\n\t*\n\t* @public\n\t*/\n\tscrollToStart: function () {\n\t\tthis[this.bottomUp ? (this.orientV ? 'scrollToBottom' : 'scrollToRight') : 'scrollToTop']();\n\t},\n\n\t/**\n\t* Scrolls to the end of the list.\n\t*\n\t* @public\n\t*/\n\tscrollToEnd: function () {\n\t\tthis[this.bottomUp ? (this.orientV ? 'scrollToTop' : 'scrollToLeft') : (this.orientV ? 'scrollToBottom' : 'scrollToRight')]();\n\t},\n\n\t/**\n\t* Re-renders the list at the current position.\n\t*\n\t* @public\n\t*/\n\trefresh: function () {\n\t\tthis.invalidatePages();\n\t\tthis.update(this[(this.orientV ? 'getScrollTop' : 'getScrollLeft')]());\n\t\tthis.stabilize();\n\n\t\t//FIXME: Necessary evil for Android 4.0.4 refresh bug\n\t\tif (platform.android === 4) {\n\t\t\tthis.twiddle();\n\t\t}\n\t},\n\n\t/**\n\t* Re-renders the list from the beginning.  This is used when changing the\n\t* data model for the list.  This also clears the selection state.\n\t*\n\t* @public\n\t*/\n\treset: function () {\n\t\tthis.getSelection().clear();\n\t\tthis.invalidateMetrics();\n\t\tthis.invalidatePages();\n\t\tthis.stabilize();\n\t\tthis.scrollToStart();\n\t},\n\n\t/**\n\t* Returns the {@link module:enyo/Selection~Selection} component that\n\t* manages the selection state for this list.\n\t*\n\t* @return {module:enyo/Selection~Selection} - The component that manages selection state for this list.\n\t* @public\n\t*/\n\tgetSelection: function () {\n\t\treturn this.$.generator.getSelection();\n\t},\n\n\t/**\n\t* Sets the selection state for the given row index.\n\t*\n\t* Modifying selection will not automatically re-render the row, so call\n\t* [renderRow()]{@link module:layout/List~List#renderRow} or [refresh()]{@link module:layout/List~List#refresh}\n\t* to update the view.\n\t*\n\t* @param {Number} index - The index of the row whose selection state is to be set.\n\t* @param {*} [data]     - Data value stored in the selection object.\n\t* @public\n\t*/\n\tselect: function (index, data) {\n\t\treturn this.getSelection().select(index, data);\n\t},\n\n\t/**\n\t* Clears the selection state for the given row index.\n\t*\n\t* Modifying selection will not automatically re-render the row, so call\n\t* [renderRow()]{@link module:layout/List~List#renderRow} or [refresh()]{@link module:layout/List~List#refresh}\n\t* to update the view.\n\t*\n\t* @param {Number} index - The index of the row whose selection state is to be cleared.\n\t* @public\n\t*/\n\tdeselect: function (index) {\n\t\treturn this.getSelection().deselect(index);\n\t},\n\n\t/**\n\t* Gets the selection state for the given row index.\n\t*\n\t* @param {Number} index - The index of the row whose selection state is\n\t* to be retrieved.\n\t* @return {Boolean} `true` if the given row is currently selected; otherwise, `false`.\n\t* @public\n\t*/\n\tisSelected: function (index) {\n\t\treturn this.$.generator.isSelected(index);\n\t},\n\n\t/**\n\t* Re-renders the specified row. Call this method after making\n\t* modifications to a row, to force it to render.\n\t*\n\t* @param {Number} index - The index of the row to be re-rendered.\n\t* @public\n    */\n    renderRow: function (index) {\n\t\tthis.$.generator.renderRow(index);\n    },\n\n\t/**\n \t* Handler for `onRenderRow` events. Updates row bounds when rows are re-rendered.\n\t*\n\t* @private\n\t*/\n\trowRendered: function (sender, event) {\n\t\tthis.updateRowBounds(event.rowIndex);\n\t},\n\n\t/**\n\t* Prepares a row to become interactive.\n\t*\n\t* @param {Number} index - The index of the row to be prepared.\n\t* @public\n\t*/\n\tprepareRow: function (index) {\n\t\tthis.$.generator.prepareRow(index);\n\t},\n\n\t/**\n\t* Restores the row to being non-interactive.\n\t*\n\t* @public\n\t*/\n\tlockRow: function () {\n\t\tthis.$.generator.lockRow();\n\t},\n\n\t/**\n\t* Performs a set of tasks by running the function `func` on a row (which\n\t* must be interactive at the time the tasks are performed). Locks the\trow\n\t* when done.\n\t*\n\t* @param {Number} index   - The index of the row to be acted upon.\n\t* @param {function} func  - The function to perform.\n\t* @param {Object} context - The context to which the function is bound.\n\t* @public\n\t*/\n\tperformOnRow: function (index, func, context) {\n\t\tthis.$.generator.performOnRow(index, func, context);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tanimateFinish: function (sender) {\n\t\tthis.twiddle();\n\t\treturn true;\n\t},\n\t/**\n\t* FIXME: Android 4.04 has issues with nested composited elements; for example, a\n\t* SwipeableItem, can incorrectly generate taps on its content when it has slid off the\n\t* screen; we address this BUG here by forcing the Scroller to 'twiddle' which corrects the\n\t* bug by provoking a dom update.\n\t*\n\t* @private\n\t*/\n\ttwiddle: function () {\n\t\tvar s = this.getStrategy();\n\t\tutils.call(s, 'twiddle');\n\t},\n\n\t/**\n\t* Returns page0 or page1 control depending on pageNumber odd/even status\n\t*\n\t* @param {Number} pageNumber  - Index of page.\n\t* @param {Boolean} checkRange - Whether to force checking `pageNumber` against\n\t* currently active pages.\n\t* @return {module:enyo/Control~Control}      - Page control for `pageNumber`.\n\t* @private\n\t*/\n\tpageForPageNumber: function (pageNumber, checkRange) {\n\t\tif (pageNumber % 2 === 0) {\n\t\t\treturn (!checkRange || (pageNumber === this.p0)) ? this.$.page0 : null;\n\t\t}\n\t\telse {\n\t\t\treturn (!checkRange || (pageNumber === this.p1)) ? this.$.page1 : null;\n\t\t}\n\t\treturn null;\n\t},\n\t/**\n\t\t---- Reorder functionality ------------\n\t*/\n\n\t/**\n\t* Determines whether the hold event should be handled as a reorder hold.\n\t*\n\t* @private\n\t*/\n\tshouldStartReordering: function (sender, event) {\n\t\tif (!this.getReorderable() ||\n\t\t\tevent.rowIndex == null ||\n\t\t\tevent.rowIndex < 0 ||\n\t\t\tthis.pinnedReorderMode ||\n\t\t\tevent.index == null ||\n\t\t\tevent.index < 0) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t/**\n\t* Processes hold event and prepares for reordering.\n\t*\n\t* @fires module:layout/List~List#onSetupReorderComponents\n\t* @private\n\t*/\n\tstartReordering: function (event) {\n\t\t// disable drag to scroll on strategy\n\t\tthis.$.strategy.listReordering = true;\n\n\t\tthis.buildReorderContainer();\n\t\tthis.doSetupReorderComponents({index: event.index});\n\t\tthis.styleReorderContainer(event);\n\n\t\tthis.draggingRowIndex = this.placeholderRowIndex = event.rowIndex;\n\t\tthis.draggingRowPage = this.pageForRow(this.draggingRowIndex);\n\t\tthis.removeDraggingRowNode = event.dispatchTarget.retainNode(event.target);\n\t\tthis.removedInitialPage = false;\n\t\tthis.itemMoved = false;\n\t\tthis.initialPageNumber = this.currentPageNumber = this.pageForRow(event.rowIndex);\n\t\tthis.prevScrollTop = this.getScrollTop();\n\n\t\t// fill row being reordered with placeholder\n\t\tthis.replaceNodeWithPlaceholder(event.rowIndex);\n\t},\n\n\t/**\n\t* Fills reorder container with draggable reorder components defined by the\n\t* application.\n\t*\n\t* @private\n\t*/\n\tbuildReorderContainer: function () {\n\t\tthis.$.reorderContainer.destroyClientControls();\n\t\tfor (var i=0;i<this.reorderComponents.length;i++) {\n\t\t\tthis.$.reorderContainer.createComponent(this.reorderComponents[i], {owner:this.owner});\n\t\t}\n\t\tthis.$.reorderContainer.render();\n\t},\n\n\t/**\n\t* Prepares floating reorder container.\n\t*\n\t* @param {Object} e - Event object.\n\t* @private\n\t*/\n\tstyleReorderContainer: function (e) {\n\t\tthis.setItemPosition(this.$.reorderContainer, e.rowIndex);\n\t\tthis.setItemBounds(this.$.reorderContainer, e.rowIndex);\n\t\tthis.$.reorderContainer.setShowing(true);\n\t\tif (this.centerReorderContainer) {\n\t\t\tthis.centerReorderContainerOnPointer(e);\n\t\t}\n\t},\n\n\t/**\n\t* Copies the innerHTML of `node` into a new component inside of\n\t* `reorderContainer`.\n\t*\n\t* @param {Node} node - The source node.\n\t* @private\n\t*/\n\tappendNodeToReorderContainer: function (node) {\n\t\tthis.$.reorderContainer.createComponent({allowHtml: true, content: node.innerHTML}).render();\n\t},\n\n\t/**\n\t* Centers the floating reorder container on the user's pointer.\n\t*\n\t* @param {Object} e - Event object.\n\t* @private\n\t*/\n\tcenterReorderContainerOnPointer: function (e) {\n\t\tvar containerPosition = dom.calcNodePosition(this.hasNode());\n\t\tvar bounds = this.$.reorderContainer.getBounds();\n\t\tvar x = e.pageX - containerPosition.left - parseInt(bounds.width, 10)/2;\n\t\tvar y = e.pageY - containerPosition.top + this.getScrollTop() - parseInt(bounds.height, 10)/2;\n\t\tif (this.getStrategyKind() != 'ScrollStrategy') {\n\t\t\tx -= this.getScrollLeft();\n\t\t\ty -= this.getScrollTop();\n\t\t}\n\t\tthis.positionReorderContainer(x, y);\n\t},\n\n\t/**\n\t* Moves the reorder container to the specified `x` and `y` coordinates.\n\t* Animates and kicks off timer to turn off animation.\n\t*\n\t* @param {Number} x - The `left` position.\n\t* @param {Number} y - The `top` position.\n\t* @private\n\t*/\n\tpositionReorderContainer: function (x,y) {\n\t\tthis.$.reorderContainer.addClass('enyo-animatedTopAndLeft');\n\t\tthis.$.reorderContainer.addStyles('left:'+x+'px;top:'+y+'px;');\n\t\tthis.setPositionReorderContainerTimeout();\n\t},\n\n\t/**\n\t* Sets a timeout to remove animation class from reorder container.\n\t*\n\t* @private\n\t*/\n\tsetPositionReorderContainerTimeout: function () {\n\t\tthis.clearPositionReorderContainerTimeout();\n\t\tthis.positionReorderContainerTimeout = setTimeout(this.bindSafely(\n\t\t\tfunction () {\n\t\t\t\tthis.$.reorderContainer.removeClass('enyo-animatedTopAndLeft');\n\t\t\t\tthis.clearPositionReorderContainerTimeout();\n\t\t\t}), 100);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tclearPositionReorderContainerTimeout: function () {\n\t\tif (this.positionReorderContainerTimeout) {\n\t\t\tclearTimeout(this.positionReorderContainerTimeout);\n\t\t\tthis.positionReorderContainerTimeout = null;\n\t\t}\n\t},\n\n\t/**\n\t* Determines whether we should handle the drag event.\n\t*\n\t* @private\n\t*/\n\tshouldDoReorderDrag: function () {\n\t\tif (!this.getReorderable() || this.draggingRowIndex < 0 || this.pinnedReorderMode) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t/**\n\t* Handles the drag event as a reorder drag.\n\t*\n\t* @private\n\t*/\n\treorderDrag: function (event) {\n\t\t// position reorder node under mouse/pointer\n\t\tthis.positionReorderNode(event);\n\n\t\t// determine if we need to auto-scroll the list\n\t\tthis.checkForAutoScroll(event);\n\n\t\t// if the current index the user is dragging over has changed, move the placeholder\n\t\tthis.updatePlaceholderPosition(event.pageY);\n\t},\n\n\t/**\n\t* Determines the row index at `pageY` (if it exists) and moves the placeholder\n\t* to that index.\n\t*\n\t* @param {Number} pageY - Position from top in pixels.\n\t* @private\n\t*/\n\tupdatePlaceholderPosition: function (pageY) {\n\t\tvar index = this.getRowIndexFromCoordinate(pageY);\n\t\tif (index !== -1) {\n\t\t\t// cursor moved over a new row, so determine direction of movement\n\t\t\tif (index >= this.placeholderRowIndex) {\n\t\t\t\tthis.movePlaceholderToIndex(Math.min(this.count, index + 1));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.movePlaceholderToIndex(index);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* Positions the reorder node based on the `dx` and `dy` of the drag event.\n\t*\n\t* @private\n\t*/\n\tpositionReorderNode: function (e) {\n\t\tvar reorderNodeBounds = this.$.reorderContainer.getBounds();\n\t\tvar left = reorderNodeBounds.left + e.ddx;\n\t\tvar top = reorderNodeBounds.top + e.ddy;\n\t\ttop = (this.getStrategyKind() == 'ScrollStrategy') ? top + (this.getScrollTop() - this.prevScrollTop) : top;\n\t\tthis.$.reorderContainer.addStyles('top: '+top+'px ; left: '+left+'px');\n\t\tthis.prevScrollTop = this.getScrollTop();\n\t},\n\n\t/**\n\t* Checks whether the list should scroll when dragging and, if so, starts the\n\t* scroll timeout timer. Auto-scrolling happens when the user drags an item\n\t* within the top/bottom boundary percentage defined in\n\t* [dragToScrollThreshold]{@link module:layout/List~List#dragToScrollThreshold}.\n\t*\n\t* @param {Object} event - Drag event.\n\t* @private\n\t*/\n\tcheckForAutoScroll: function (event) {\n\t\tvar position = dom.calcNodePosition(this.hasNode());\n\t\tvar bounds = this.getBounds();\n\t\tvar perc;\n\t\tthis.autoscrollPageY = event.pageY;\n\t\tif (event.pageY - position.top < bounds.height * this.dragToScrollThreshold) {\n\t\t\tperc = 100*(1 - ((event.pageY - position.top) / (bounds.height * this.dragToScrollThreshold)));\n\t\t\tthis.scrollDistance = -1*perc;\n\t\t} else if (event.pageY - position.top > bounds.height * (1 - this.dragToScrollThreshold)) {\n\t\t\tperc = 100*((event.pageY - position.top - bounds.height*(1 - this.dragToScrollThreshold)) / (bounds.height - (bounds.height * (1 - this.dragToScrollThreshold))));\n\t\t\tthis.scrollDistance = 1*perc;\n\t\t} else {\n\t\t\tthis.scrollDistance = 0;\n\t\t}\n\t\t// stop scrolling if distance is zero (i.e., user isn't scrolling to the edges of\n\t\t// the list); otherwise, start it if not already started\n\t\tif (this.scrollDistance === 0) {\n\t\t\tthis.stopAutoScrolling();\n\t\t} else {\n\t\t\tif (!this.autoScrollTimeout) {\n\t\t\t\tthis.startAutoScrolling();\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* Stops auto-scrolling.\n\t*\n\t* @private\n\t*/\n\tstopAutoScrolling: function () {\n\t\tif (this.autoScrollTimeout) {\n\t\t\tclearTimeout(this.autoScrollTimeout);\n\t\t\tthis.autoScrollTimeout = null;\n\t\t}\n\t},\n\n\t/**\n\t* Starts auto-scrolling.\n\t*\n\t* @private\n\t*/\n\tstartAutoScrolling: function () {\n\t\tthis.autoScrollTimeout = setInterval(this.bindSafely(this.autoScroll), this.autoScrollTimeoutMS);\n\t},\n\n\t/**\n\t* Scrolls the list by the distance specified in\n\t* [scrollDistance]{@link module:layout/List~List#scrollDistance}.\n\t*\n\t* @private\n\t*/\n\tautoScroll: function () {\n\t\tif (this.scrollDistance === 0) {\n\t\t\tthis.stopAutoScrolling();\n\t\t} else {\n\t\t\tif (!this.autoScrollTimeout) {\n\t\t\t\tthis.startAutoScrolling();\n\t\t\t}\n\t\t}\n\t\tthis.setScrollPosition(this.getScrollPosition() + this.scrollDistance);\n\t\tthis.positionReorderNode({ddx: 0, ddy: 0});\n\n\t\t// if the current index the user is dragging over has changed, move the placeholder\n\t\tthis.updatePlaceholderPosition(this.autoscrollPageY);\n\t},\n\n\t/**\n\t* Moves the placeholder (i.e., the gap between rows) to the row currently\n\t* under the user's pointer. This provides a visual cue, showing the user\n\t* where the item being dragged will go if it is dropped.\n\t*\n\t* @param {Number} index - The row index.\n\t*/\n\tmovePlaceholderToIndex: function (index) {\n\t\tvar node, nodeParent;\n\t\tif (index < 0) {\n\t\t\treturn;\n\t\t}\n\t\telse if (index >= this.count) {\n\t\t\tnode = null;\n\t\t\tnodeParent = this.pageForPageNumber(this.pageForRow(this.count - 1)).hasNode();\n\t\t}\n\t\telse {\n\t\t\tnode = this.$.generator.fetchRowNode(index);\n\t\t\tnodeParent = node.parentNode;\n\t\t}\n\t\t// figure next page for placeholder\n\t\tvar nextPageNumber = this.pageForRow(index);\n\n\t\t// don't add pages beyond the original page count\n\t\tif (nextPageNumber >= this.pageCount) {\n\t\t\tnextPageNumber = this.currentPageNumber;\n\t\t}\n\n\t\t// move the placeholder to just after our 'index' node\n\t\tnodeParent.insertBefore(\n\t\t\tthis.placeholderNode,\n\t\t\tnode);\n\n\t\tif (this.currentPageNumber !== nextPageNumber) {\n\t\t\t// if moving to different page, recalculate page sizes and reposition pages\n\t\t\tthis.updatePageSize(this.currentPageNumber);\n\t\t\tthis.updatePageSize(nextPageNumber);\n\t\t\tthis.updatePagePositions(nextPageNumber);\n\t\t}\n\n\t\t// save updated state\n\t\tthis.placeholderRowIndex = index;\n\t\tthis.currentPageNumber = nextPageNumber;\n\n\t\t// remember that we moved an item (to prevent pinning at the wrong time)\n\t\tthis.itemMoved = true;\n\t},\n\n\t/**\n\t* Turns off reordering. If the user didn't drag the item being reordered\n\t* outside of its original position, enters pinned reorder mode.\n\t*\n\t* @private\n\t*/\n\tfinishReordering: function (sender, event) {\n\t\tif (!this.isReordering() || this.pinnedReorderMode || this.completeReorderTimeout) {\n\t\t\treturn;\n\t\t}\n\t\tthis.stopAutoScrolling();\n\t\t// enable drag-scrolling on strategy\n\t\tthis.$.strategy.listReordering = false;\n\t\t// animate reorder container to proper position and then complete\n\t\t// reordering actions\n\t\tthis.moveReorderedContainerToDroppedPosition(event);\n\t\tthis.completeReorderTimeout = setTimeout(\n\t\t\tthis.bindSafely(this.completeFinishReordering, event), 100);\n\n\t\tevent.preventDefault();\n\t\treturn true;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tmoveReorderedContainerToDroppedPosition: function () {\n\t\tvar offset = this.getRelativeOffset(this.placeholderNode, this.hasNode());\n\t\tvar top = (this.getStrategyKind() == 'ScrollStrategy') ? offset.top : offset.top - this.getScrollTop();\n\t\tvar left = offset.left - this.getScrollLeft();\n\t\tthis.positionReorderContainer(left, top);\n\t},\n\n\t/**\n\t* After the reordered item has been animated to its position, completes\n\t* the reordering logic.\n\t*\n\t* @private\n\t*/\n\tcompleteFinishReordering: function (event) {\n\t\tthis.completeReorderTimeout = null;\n\t\t// adjust placeholderRowIndex to now be the final resting place\n\t\tif (this.placeholderRowIndex > this.draggingRowIndex) {\n\t\t\tthis.placeholderRowIndex = Math.max(0, this.placeholderRowIndex - 1);\n\t\t}\n\t\t// if the user dropped the item in the same location where it was picked up, and they\n\t\t// didn't move any other items in the process, pin the item and go into pinned reorder mode\n\t\tif (this.draggingRowIndex == this.placeholderRowIndex &&\n\t\t\tthis.pinnedReorderComponents.length && !this.pinnedReorderMode && !this.itemMoved) {\n\t\t\tthis.beginPinnedReorder(event);\n\t\t\treturn;\n\t\t}\n\t\tthis.removeDraggingRowNode();\n\t\tthis.removePlaceholderNode();\n\t\tthis.emptyAndHideReorderContainer();\n\t\t// clear this early to prevent scroller code from using disappeared placeholder\n\t\tthis.pinnedReorderMode = false;\n\t\tthis.reorderRows(event);\n\t\tthis.draggingRowIndex = this.placeholderRowIndex = -1;\n\t\tthis.refresh();\n\t},\n\n\t/**\n\t* Enters pinned reorder mode.\n\t*\n\t* @fires module:layout/List~List#onSetupPinnedReorderComponents\n\t* @private\n\t*/\n\tbeginPinnedReorder: function (event) {\n\t\tthis.buildPinnedReorderContainer();\n\t\tthis.doSetupPinnedReorderComponents(utils.mixin(event, {index: this.draggingRowIndex}));\n\t\tthis.pinnedReorderMode = true;\n\t\tthis.initialPinPosition = event.pageY;\n\t},\n\n\t/**\n\t* Clears contents of reorder container, then hides.\n\t*\n\t* @private\n\t*/\n\temptyAndHideReorderContainer: function () {\n\t\tthis.$.reorderContainer.destroyComponents();\n\t\tthis.$.reorderContainer.setShowing(false);\n\t},\n\n\t/**\n\t* Fills reorder container with pinned controls.\n\t*\n\t* @private\n\t*/\n\tbuildPinnedReorderContainer: function () {\n\t\tthis.$.reorderContainer.destroyClientControls();\n\t\tfor (var i=0;i<this.pinnedReorderComponents.length;i++) {\n\t\t\tthis.$.reorderContainer.createComponent(this.pinnedReorderComponents[i], {owner:this.owner});\n\t\t}\n\t\tthis.$.reorderContainer.render();\n\t},\n\n\t/**\n\t* Swaps the rows that were reordered, and sends up reorder event.\n\t*\n\t* @fires module:layout/List~List#onReorder\n\t* @private\n\t*/\n\treorderRows: function (event) {\n\t\t// send reorder event\n\t\tthis.doReorder(this.makeReorderEvent(event));\n\t\t// update display\n\t\tthis.positionReorderedNode();\n\t\t// fix indices for reordered rows\n\t\tthis.updateListIndices();\n\t},\n\n\t/**\n\t* Adds `reorderTo` and `reorderFrom` properties to the reorder event.\n\t*\n\t* @private\n\t*/\n\tmakeReorderEvent: function (event) {\n\t\tevent.reorderFrom = this.draggingRowIndex;\n\t\tevent.reorderTo = this.placeholderRowIndex;\n\t\treturn event;\n\t},\n\n\t/**\n\t* Moves the node being reordered to its new position and shows it.\n\t*\n\t* @private\n\t*/\n\tpositionReorderedNode: function () {\n\t\t// only do this if the page with the initial item is still rendered\n\t\tif (!this.removedInitialPage) {\n\t\t\tvar insertNode = this.$.generator.fetchRowNode(this.placeholderRowIndex);\n\t\t\tif (insertNode) {\n\t\t\t\tinsertNode.parentNode.insertBefore(this.hiddenNode, insertNode);\n\t\t\t\tthis.showNode(this.hiddenNode);\n\t\t\t}\n\t\t\tthis.hiddenNode = null;\n\t\t\tif (this.currentPageNumber != this.initialPageNumber) {\n\t\t\t\tvar mover, movee;\n\t\t\t\tvar currentPage = this.pageForPageNumber(this.currentPageNumber);\n\t\t\t\tvar otherPage = this.pageForPageNumber(this.currentPageNumber + 1);\n\t\t\t\t// if moved down, move current page's firstChild to the end of previous page\n\t\t\t\tif (this.initialPageNumber < this.currentPageNumber) {\n\t\t\t\t\tmover = currentPage.hasNode().firstChild;\n\t\t\t\t\totherPage.hasNode().appendChild(mover);\n\t\t\t\t// if moved up, move current page's lastChild before previous page's firstChild\n\t\t\t\t} else {\n\t\t\t\t\tmover = currentPage.hasNode().lastChild;\n\t\t\t\t\tmovee = otherPage.hasNode().firstChild;\n\t\t\t\t\totherPage.hasNode().insertBefore(mover, movee);\n\t\t\t\t}\n\t\t\t\tthis.correctPageSizes();\n\t\t\t\tthis.updatePagePositions(this.initialPageNumber);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* Updates indices of list items as needed to preserve reordering.\n\t*\n\t* @private\n\t*/\n\tupdateListIndices: function () {\n\t\t// don't do update if we've moved further than one page, refresh instead\n\t\tif (this.shouldDoRefresh()) {\n\t\t\tthis.refresh();\n\t\t\tthis.correctPageSizes();\n\t\t\treturn;\n\t\t}\n\n\t\tvar from = Math.min(this.draggingRowIndex, this.placeholderRowIndex);\n\t\tvar to = Math.max(this.draggingRowIndex, this.placeholderRowIndex);\n\t\tvar direction = (this.draggingRowIndex - this.placeholderRowIndex > 0) ? 1 : -1;\n\t\tvar node, i, newIndex, currentIndex;\n\n\t\tif (direction === 1) {\n\t\t\tnode = this.$.generator.fetchRowNode(this.draggingRowIndex);\n\t\t\tif (node) {\n\t\t\t\tnode.setAttribute('data-enyo-index', 'reordered');\n\t\t\t}\n\t\t\tfor (i=(to-1),newIndex=to;i>=from;i--) {\n\t\t\t\tnode = this.$.generator.fetchRowNode(i);\n\t\t\t\tif (!node) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcurrentIndex = parseInt(node.getAttribute('data-enyo-index'), 10);\n\t\t\t\tnewIndex = currentIndex + 1;\n\t\t\t\tnode.setAttribute('data-enyo-index', newIndex);\n\t\t\t}\n\t\t\tnode = this.hasNode().querySelector('[data-enyo-index=\"reordered\"]');\n\t\t\tnode.setAttribute('data-enyo-index', this.placeholderRowIndex);\n\n\t\t} else {\n\t\t\tnode = this.$.generator.fetchRowNode(this.draggingRowIndex);\n\t\t\tif (node) {\n\t\t\t\tnode.setAttribute('data-enyo-index', this.placeholderRowIndex);\n\t\t\t}\n\t\t\tfor (i=(from+1), newIndex=from;i<=to;i++) {\n\t\t\t\tnode = this.$.generator.fetchRowNode(i);\n\t\t\t\tif (!node) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcurrentIndex = parseInt(node.getAttribute('data-enyo-index'), 10);\n\t\t\t\tnewIndex = currentIndex - 1;\n\t\t\t\tnode.setAttribute('data-enyo-index', newIndex);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* Determines whether an item was reordered far enough that it warrants a refresh.\n\t*\n\t* @private\n\t*/\n\tshouldDoRefresh: function () {\n\t\treturn (Math.abs(this.initialPageNumber - this.currentPageNumber) > 1);\n\t},\n\n\t/**\n\t* Gets node height, width, top, and left values.\n\t*\n\t* @private\n\t*/\n\tgetNodeStyle: function (index) {\n\t\tvar node = this.$.generator.fetchRowNode(index);\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\t\tvar offset = this.getRelativeOffset(node, this.hasNode());\n\t\tvar dimensions = dom.getBounds(node);\n\t\treturn {h: dimensions.height, w: dimensions.width, left: offset.left, top: offset.top};\n\t},\n\n\t/**\n\t* Gets offset relative to a positioned ancestor node.\n\t*\n\t* @private\n\t*/\n\tgetRelativeOffset: function (n, p) {\n\t\tvar ro = {top: 0, left: 0};\n\t\tif (n !== p && n.parentNode) {\n\t\t\tdo {\n\t\t\t\tro.top += n.offsetTop || 0;\n\t\t\t\tro.left += n.offsetLeft || 0;\n\t\t\t\tn = n.offsetParent;\n\t\t\t} while (n && n !== p);\n\t\t}\n\t\treturn ro;\n\t},\n\n\t/**\n\t* Hides the DOM node for the row at `index` and inserts the placeholder node before it.\n\t*\n\t* @param {Number} index - The index of the row whose DOM node will be hidden.\n\t* @private\n\t*/\n\treplaceNodeWithPlaceholder: function (index) {\n\t\tvar node = this.$.generator.fetchRowNode(index);\n\t\tif (!node) {\n\t\t\tlogger.log('No node - ' + index);\n\t\t\treturn;\n\t\t}\n\t\t// create and style placeholder node\n\t\tthis.placeholderNode = this.createPlaceholderNode(node);\n\t\t// hide existing node\n\t\tthis.hiddenNode = this.hideNode(node);\n\t\t// insert placeholder node where original node was\n\t\tvar currentPage = this.pageForPageNumber(this.currentPageNumber);\n\t\tcurrentPage.hasNode().insertBefore(this.placeholderNode, this.hiddenNode);\n\t},\n\n\t/**\n\t* Creates and returns a placeholder node with dimensions matching those of\n\t* the passed-in node.\n\t*\n\t* @param {Node} node - Node on which to base the placeholder dimensions.\n\t* @private\n\t*/\n\tcreatePlaceholderNode: function (node) {\n\t\tvar placeholderNode = this.$.placeholder.hasNode().cloneNode(true);\n\t\tvar nodeDimensions = dom.getBounds(node);\n\t\tplaceholderNode.style.height = nodeDimensions.height + 'px';\n\t\tplaceholderNode.style.width = nodeDimensions.width + 'px';\n\t\treturn placeholderNode;\n\t},\n\n\t/**\n\t* Removes the placeholder node from the DOM.\n\t*\n\t* @private\n\t*/\n\tremovePlaceholderNode: function () {\n\t\tthis.removeNode(this.placeholderNode);\n\t\tthis.placeholderNode = null;\n\t},\n\n\t/**\n\t* Removes the passed-in node from the DOM.\n\t*\n\t* @private\n\t*/\n\tremoveNode: function (node) {\n\t\tif (!node || !node.parentNode) {\n\t\t\treturn;\n\t\t}\n\t\tnode.parentNode.removeChild(node);\n\t},\n\n\t/**\n\t* Updates `this.pageSizes` to support the placeholder node's jumping\n\t* from one page to the next.\n\t*\n\t* @param {Number} pageNumber\n\t* @private\n\t*/\n\tupdatePageSize: function (pageNumber) {\n\t\tif (pageNumber < 0) {\n\t\t\treturn;\n\t\t}\n\t\tvar pageControl = this.pageForPageNumber(pageNumber, true);\n\t\tif (pageControl) {\n\t\t\tvar s0 = this.pageSizes[pageNumber];\n\t\t\t// FIXME: use height/width depending on orientation\n\t\t\tvar pageSize = Math.max(1, pageControl.getBounds().height);\n\t\t\tthis.pageSizes[pageNumber] = pageSize;\n\t\t\tthis.portSize += pageSize - s0;\n\t\t}\n\t},\n\n\t/**\n\t* Repositions [currentPageNumber]{@link module:layout/List~List#currentPageNumber} and\n\t* `nextPageNumber` pages to support the placeholder node's jumping from one\n\t* page to the next.\n\t*\n\t* @param {Number} nextPageNumber [description]\n\t* @private\n\t*/\n\tupdatePagePositions: function (nextPageNumber) {\n\t\tthis.positionPage(this.currentPageNumber, this.pageForPageNumber(this.currentPageNumber));\n\t\tthis.positionPage(nextPageNumber, this.pageForPageNumber(nextPageNumber));\n\t},\n\n\t/**\n\t* Corrects page sizes array after reorder is complete.\n\t*\n\t* @private\n\t*/\n\tcorrectPageSizes: function () {\n\t\tvar initPageNumber = this.initialPageNumber%2;\n\t\tthis.updatePageSize(this.currentPageNumber, this.$['page'+this.currentPage]);\n\t\tif (initPageNumber != this.currentPageNumber) {\n\t\t\tthis.updatePageSize(this.initialPageNumber, this.$['page'+initPageNumber]);\n\t\t}\n\t},\n\n\t/**\n\t* Hides a DOM node.\n\t*\n\t* @private\n\t*/\n\thideNode: function (node) {\n\t\tnode.style.display = 'none';\n\t\treturn node;\n\t},\n\n\t/**\n\t* Shows a DOM node.\n\t*\n\t* @private\n\t*/\n\tshowNode: function (node) {\n\t\tnode.style.display = 'block';\n\t\treturn node;\n\t},\n\n\t/**\n\t* Called by client code to finalize a pinned mode reordering, e.g., when the \"Drop\"\n\t* button is pressed on the pinned placeholder row.\n\t*\n\t* @todo Seems incorrect to have an event on the signature for a public API\n\t* @param {Object} event - A mouse/touch event.\n\t* @public\n\t*/\n\tdropPinnedRow: function (event) {\n\t\t// animate reorder container to proper position and then complete reording actions\n\t\tthis.moveReorderedContainerToDroppedPosition(event);\n\t\tthis.completeReorderTimeout = setTimeout(\n\t\t\tthis.bindSafely(this.completeFinishReordering, event), 100);\n\t\treturn;\n\t},\n\n\t/**\n\t* Called by client code to cancel a pinned mode reordering.\n\t*\n\t* @todo Seems incorrect to have an event on the signature for a public API\n\t* @param {Object} event - A mouse/touch event.\n\t* @public\n\t*/\n\tcancelPinnedMode: function (event) {\n\t\t// make it look like we're dropping in original location\n\t\tthis.placeholderRowIndex = this.draggingRowIndex;\n\t\tthis.dropPinnedRow(event);\n\t},\n\n\t/**\n\t* Returns the row index that is under the given `y`-position on the page.  If the\n\t* position is off the end of the list, `this.count` is returned. If the position\n\t* is before the start of the list, `-1` is returned.\n\t*\n\t* @param {Number} y - `y` position in pixels in relation to the page.\n\t* @return {Number}  - The index of the row at the specified position.\n\t* @private\n\t*/\n\tgetRowIndexFromCoordinate: function (y) {\n\t\t// FIXME: this code only works with vertical lists\n\t\tvar cursorPosition = this.getScrollTop() + y - dom.calcNodePosition(this.hasNode()).top;\n\t\t// happens if we try to drag past top of list\n\t\tif (cursorPosition < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tvar pageInfo = this.positionToPageInfo(cursorPosition);\n\t\tvar rows = (pageInfo.no == this.p0) ? this.p0RowBounds : this.p1RowBounds;\n\t\t// might have only rendered one page, so catch that here\n\t\tif (!rows) {\n\t\t\treturn this.count;\n\t\t}\n\t\tvar posOnPage = pageInfo.pos;\n\t\tvar placeholderHeight = this.placeholderNode ? dom.getBounds(this.placeholderNode).height : 0;\n\t\tvar totalHeight = 0;\n\t\tfor (var i=pageInfo.startRow; i <= pageInfo.endRow; ++i) {\n\t\t\t// do extra check for row that has placeholder as we'll return -1 here for no match\n\t\t\tif (i === this.placeholderRowIndex) {\n\t\t\t\t// for placeholder\n\t\t\t\ttotalHeight += placeholderHeight;\n\t\t\t\tif (totalHeight >= posOnPage) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// originally dragged row is hidden, so don't count it\n\t\t\tif (i !== this.draggingRowIndex) {\n\t\t\t\ttotalHeight += rows[i].height;\n\t\t\t\tif (totalHeight >= posOnPage) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn i;\n\t},\n\n\t/**\n\t* Gets the position of a node (identified via index) on the page.\n\t*\n\t* @return {Object} The position of the row node.\n\t* @private\n\t*/\n\tgetIndexPosition: function (index) {\n\t\treturn dom.calcNodePosition(this.$.generator.fetchRowNode(index));\n\t},\n\n\t/**\n\t* Sets the specified control's position to match that of the list row at `index`.\n\t*\n\t* @param {module:enyo/Control~Control} item - The control to reposition.\n\t* @param {Number} index      - The index of the row whose position is to be matched.\n\t* @private\n\t*/\n\tsetItemPosition: function (item, index) {\n\t\tvar clonedNodeStyle = this.getNodeStyle(index);\n\t\tvar top = (this.getStrategyKind() == 'ScrollStrategy') ? clonedNodeStyle.top : clonedNodeStyle.top - this.getScrollTop();\n\t\tvar styleStr = 'top:'+top+'px; left:'+clonedNodeStyle.left+'px;';\n\t\titem.addStyles(styleStr);\n\t},\n\n\t/**\n\t* Sets the specified control's width and height to match those of the list row at `index`.\n\t*\n\t* @param {module:enyo/Control~Control} item - The control to reposition.\n\t* @param {Number} index      - The index of the row whose width and height are to be matched.\n\t* @private\n\t*/\n\tsetItemBounds: function (item, index) {\n\t\tvar clonedNodeStyle = this.getNodeStyle(index);\n\t\tvar styleStr = 'width:'+clonedNodeStyle.w+'px; height:'+clonedNodeStyle.h+'px;';\n\t\titem.addStyles(styleStr);\n\t},\n\n\t/**\n\t* When in pinned reorder mode, repositions the pinned placeholder when the\n\t* user has scrolled far enough.\n\t*\n\t* @private\n\t*/\n\treorderScroll: function (sender, e) {\n\t\t// if we are using the standard scroll strategy, we have to move the pinned row with the scrolling\n\t\tif (this.getStrategyKind() == 'ScrollStrategy') {\n\t\t\tthis.$.reorderContainer.addStyles('top:'+(this.initialPinPosition+this.getScrollTop()-this.rowSize)+'px;');\n\t\t}\n\t\t// y coordinate on screen of the pinned item doesn't change as we scroll things\n\t\tthis.updatePlaceholderPosition(this.initialPinPosition);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\thideReorderingRow: function () {\n\t\tvar hiddenNode = this.hasNode().querySelector('[data-enyo-index=\"' + this.draggingRowIndex + '\"]');\n\t\t// hide existing node\n\t\tif (hiddenNode) {\n\t\t\tthis.hiddenNode = this.hideNode(hiddenNode);\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tisReordering: function () {\n\t\treturn (this.draggingRowIndex > -1);\n\t},\n\n\t/**\n\t\t---- Swipeable functionality ------------\n\t*/\n\n\t/**\n\t* @private\n\t*/\n\tisSwiping: function () {\n\t\t// we're swiping when the index is set and we're not in the middle of completing or backing out a swipe\n\t\treturn (this.swipeIndex != null && !this.swipeComplete && this.swipeDirection != null);\n\t},\n\n\t/**\n\t* When a drag starts, gets the direction of the drag as well as the index\n\t* of the item being dragged, and resets any pertinent values. Then kicks\n\t* off the swipe sequence.\n\t*\n\t* @private\n\t*/\n\tswipeDragStart: function (sender, event) {\n\t\t// if we're not on a row or the swipe is vertical or if we're in the middle of reordering, just say no\n\t\tif (event.index == null || event.vertical) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// if we are waiting to complete a swipe, complete it\n\t\tif (this.completeSwipeTimeout) {\n\t\t\tthis.completeSwipe(event);\n\t\t}\n\n\t\t// reset swipe complete flag\n\t\tthis.swipeComplete = false;\n\n\t\tif (this.swipeIndex != event.index) {\n\t\t\tthis.clearSwipeables();\n\t\t\tthis.swipeIndex = event.index;\n\t\t}\n\t\tthis.swipeDirection = event.xDirection;\n\n\t\t// start swipe sequence only if we are not currently showing a persistent item\n\t\tif (!this.persistentItemVisible) {\n\t\t\tthis.startSwipe(event);\n\t\t}\n\n\t\t// reset dragged distance (for dragfinish)\n\t\tthis.draggedXDistance = 0;\n\t\tthis.draggedYDistance = 0;\n\n\t\treturn true;\n\t},\n\n\t/**\n\t* When a drag is in progress, updates the position of the swipeable\n\t* container based on the `ddx` of the event.\n\t*\n\t* @private\n\t*/\n\tswipeDrag: function (sender, event) {\n\t\t// if a persistent swipeableItem is still showing, handle it separately\n\t\tif (this.persistentItemVisible) {\n\t\t\tthis.dragPersistentItem(event);\n\t\t\treturn this.preventDragPropagation;\n\t\t}\n\t\t// early exit if there's no matching dragStart to set item\n\t\tif (!this.isSwiping()) {\n\t\t\treturn false;\n\t\t}\n\t\t// apply new position\n\t\tthis.dragSwipeableComponents(this.calcNewDragPosition(event.ddx));\n\t\t// save dragged distance (for dragfinish)\n\t\tthis.draggedXDistance = event.dx;\n\t\tthis.draggedYDistance = event.dy;\n\t\t// save last meaningful (non-zero) and new direction (for swipeDragFinish)\n\t\tif (event.xDirection != this.lastSwipeDirection && event.xDirection) {\n\t\t\tthis.lastSwipeDirection = event.xDirection;\n\t\t}\n\t\treturn true;\n\t},\n\n\t/*\n\t* When the current drag completes, decides whether to complete the swipe\n\t* based on how far the user pulled the swipeable container.\n\t*\n\t* @private\n\t*/\n\tswipeDragFinish: function (sender, event) {\n\t\t// if a persistent swipeableItem is still showing, complete drag away or bounce\n\t\tif (this.persistentItemVisible) {\n\t\t\tthis.dragFinishPersistentItem(event);\n\t\t// early exit if there's no matching dragStart to set item\n\t\t} else if (!this.isSwiping()) {\n\t\t\treturn false;\n\t\t// otherwise if user dragged more than 20% of the width, complete the swipe. if not, back out.\n\t\t} else {\n\t\t\tvar percentageDragged = this.calcPercentageDragged(this.draggedXDistance);\n\t\t\tif ((percentageDragged > this.percentageDraggedThreshold) && (this.lastSwipeDirection === this.swipeDirection)) {\n\t\t\t\tthis.swipe(this.fastSwipeSpeedMS);\n\t\t\t} else {\n\t\t\t\tthis.backOutSwipe(event);\n\t\t\t}\n\t\t}\n\n\t\treturn this.preventDragPropagation;\n\t},\n\n\t/**\n\t* Reorder takes precedence over swipes, and not having it turned on or swipeable controls\n\t* defined also disables this.\n\t*\n\t* @private\n\t*/\n\tisSwipeable: function () {\n\t\treturn this.enableSwipe && this.$.swipeableComponents.controls.length !== 0 &&\n\t\t\t!this.isReordering() && !this.pinnedReorderMode;\n\t},\n\n\t/**\n\t* Positions the swipeable components block at the current row.\n\t*\n\t* @param {Number} index      - The row index.\n\t* @param {Number} xDirection - Value of `xDirection` from drag event (`1` = right,\n\t* `-1` = left).\n\t* @private\n\t*/\n\tpositionSwipeableContainer: function (index, xDirection) {\n\t\tvar node = this.$.generator.fetchRowNode(index);\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\t\tvar offset = this.getRelativeOffset(node, this.hasNode());\n\t\tvar dimensions = dom.getBounds(node);\n\t\tvar x = (xDirection == 1) ? -1*dimensions.width : dimensions.width;\n\t\tthis.$.swipeableComponents.addStyles('top: '+offset.top+'px; left: '+x+'px; height: '+dimensions.height+'px; width: '+dimensions.width+'px;');\n\t},\n\n\t/**\n\t* Calculates new position for the swipeable container based on the user's\n\t* drag action. Don't allow the container to drag beyond either edge.\n\t*\n\t* @param {Number} dx - Amount of change in `x` position.\n\t* @return {Number}\n\t* @private\n\t*/\n\tcalcNewDragPosition: function (dx) {\n\t\tvar parentBounds = this.$.swipeableComponents.getBounds();\n\t\tvar xPos = parentBounds.left;\n\t\tvar dimensions = this.$.swipeableComponents.getBounds();\n\t\tvar xlimit = (this.swipeDirection == 1) ? 0 : -1*dimensions.width;\n\t\tvar x = (this.swipeDirection == 1)\n\t\t\t? (xPos + dx > xlimit)\n\t\t\t\t? xlimit\n\t\t\t\t: xPos + dx\n\t\t\t: (xPos + dx < xlimit)\n\t\t\t\t? xlimit\n\t\t\t\t: xPos + dx;\n\t\treturn x;\n\t},\n\n\t/**\n\t* Positions the swipeable components.\n\t*\n\t* @param {Number} x - New `left` position.\n\t* @private\n\t*/\n\tdragSwipeableComponents: function (x) {\n\t\tthis.$.swipeableComponents.applyStyle('left',x+'px');\n\t},\n\n\t/**\n\t* Begins swiping sequence by positioning the swipeable container and\n\t* bubbling the `setupSwipeItem` event.\n\t*\n\t* @param {Object} e - Event\n\t* @fires module:layout/List~List#onSetupSwipeItem\n\t* @private\n\t*/\n\tstartSwipe: function (e) {\n\t\t// modify event index to always have this swipeItem value\n\t\te.index = this.swipeIndex;\n\t\tthis.positionSwipeableContainer(this.swipeIndex, e.xDirection);\n\t\tthis.$.swipeableComponents.setShowing(true);\n\t\tthis.setPersistentItemOrigin(e.xDirection);\n\t\tthis.doSetupSwipeItem(e);\n\t},\n\n\t/**\n\t* If a persistent swipeableItem is still showing, drags it away or bounces it.\n\t*\n\t* @param {Object} e - Event\n\t* @private\n\t*/\n\tdragPersistentItem: function (e) {\n\t\tvar xPos = 0;\n\t\tvar x = (this.persistentItemOrigin == 'right')\n\t\t\t? Math.max(xPos, (xPos + e.dx))\n\t\t\t: Math.min(xPos, (xPos + e.dx));\n\t\tthis.$.swipeableComponents.applyStyle('left',x+'px');\n\t},\n\n\t/**\n\t* If a persistent swipeableItem is still showing, completes drag away or bounce.\n\t*\n\t* @param {Object} e - Event\n\t* @private\n\t*/\n\tdragFinishPersistentItem: function (e) {\n\t\tvar completeSwipe = (this.calcPercentageDragged(e.dx) > 0.2);\n\t\tvar dir = (e.dx > 0) ? 'right' : (e.dx < 0) ? 'left' : null;\n\t\tif (this.persistentItemOrigin == dir) {\n\t\t\tif (completeSwipe) {\n\t\t\t\tthis.slideAwayItem();\n\t\t\t} else {\n\t\t\t\tthis.bounceItem(e);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.bounceItem(e);\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tsetPersistentItemOrigin: function (xDirection) {\n\t\tthis.persistentItemOrigin = xDirection == 1 ? 'left' : 'right';\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tcalcPercentageDragged: function (dx) {\n\t\treturn Math.abs(dx/this.$.swipeableComponents.getBounds().width);\n\t},\n\n\t/**\n\t* Completes a swipe animation in the specified number of milliseconds.\n\t*\n\t* @param {Number} speed - Time in milliseconds.\n\t* @private\n\t*/\n\tswipe: function (speed) {\n\t\tthis.swipeComplete = true;\n\t\tthis.animateSwipe(0, speed);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tbackOutSwipe: function () {\n\t\tvar dimensions = this.$.swipeableComponents.getBounds();\n\t\tvar x = (this.swipeDirection == 1) ? -1*dimensions.width : dimensions.width;\n\t\tthis.animateSwipe(x, this.fastSwipeSpeedMS);\n\t\tthis.swipeDirection = null;\n\t},\n\n\t/**\n\t* Returns persisted swipeable components to being visible if not dragged back\n\t* beyond threshold.\n\t*\n\t* @private\n\t*/\n\tbounceItem: function () {\n\t\tvar bounds = this.$.swipeableComponents.getBounds();\n\t\tif (bounds.left != bounds.width) {\n\t\t\tthis.animateSwipe(0, this.normalSwipeSpeedMS);\n\t\t}\n\t},\n\n\t/**\n\t* Animates the swipeable components away starting from their current position.\n\t*\n\t* @private\n\t*/\n\tslideAwayItem: function () {\n\t\tvar $item = this.$.swipeableComponents;\n\t\tvar parentWidth = $item.getBounds().width;\n\t\tvar xPos = (this.persistentItemOrigin == 'left') ? -1*parentWidth : parentWidth;\n\t\tthis.animateSwipe(xPos, this.normalSwipeSpeedMS);\n\t\tthis.persistentItemVisible = false;\n\t\tthis.setPersistSwipeableItem(false);\n\t},\n\n\t/**\n\t* Hides the swipeable components.\n\t*\n\t* @private\n\t*/\n\tclearSwipeables: function () {\n\t\tthis.$.swipeableComponents.setShowing(false);\n\t\tthis.persistentItemVisible = false;\n\t\tthis.setPersistSwipeableItem(false);\n\t},\n\n\t/**\n\t* Completes swipe and hides active swipeable item.\n\t*\n\t* @fires module:layout/List~List#onSwipeComplete\n\t* @private\n\t*/\n\tcompleteSwipe: function () {\n\t\tif (this.completeSwipeTimeout) {\n\t\t\tclearTimeout(this.completeSwipeTimeout);\n\t\t\tthis.completeSwipeTimeout = null;\n\t\t}\n\t\t// if this wasn't a persistent item, hide it upon completion and send swipe complete event\n\t\tif (!this.getPersistSwipeableItem()) {\n\t\t\tthis.$.swipeableComponents.setShowing(false);\n\t\t\t// if the swipe was completed, update the current row and bubble swipeComplete event\n\t\t\tif (this.swipeComplete) {\n\t\t\t\tthis.doSwipeComplete({index: this.swipeIndex, xDirection: this.swipeDirection});\n\t\t\t}\n\t\t} else {\n\t\t\t// persistent item will only be visible if the swipe was completed\n\t\t\tif (this.swipeComplete) {\n\t\t\t\tthis.persistentItemVisible = true;\n\t\t\t}\n\t\t}\n\t\tthis.swipeIndex = null;\n\t\tthis.swipeDirection = null;\n\t},\n\n\t/**\n\t* Animates a swipe starting from the current position to the specified new\n\t* position `(targetX)` over the specified length of time `(totalTimeMS)`.\n\t*\n\t* @param {Number} targetX     - The target `left` position.\n\t* @param {Number} totalTimeMS - Time in milliseconds.\n\t* @private\n\t*/\n\tanimateSwipe: function (targetX, totalTimeMS) {\n\t\tvar t0 = utils.now();\n\t\tvar $item = this.$.swipeableComponents;\n\t\tvar origX = parseInt($item.getBounds().left, 10);\n\t\tvar xDelta = targetX - origX;\n\n\t\tthis.stopAnimateSwipe();\n\n\t\tvar fn = this.bindSafely(function () {\n\t\t\tvar t = utils.now() - t0;\n\t\t\tvar percTimeElapsed = t/totalTimeMS;\n\t\t\tvar currentX = origX + (xDelta)*Math.min(percTimeElapsed,1);\n\n\t\t\t// set new left\n\t\t\t$item.applyStyle('left', currentX+'px');\n\n\t\t\t// schedule next frame\n\t\t\tthis.job = animation.requestAnimationFrame(fn);\n\n\t\t\t// potentially override animation TODO\n\n\t\t\t// go until we've hit our total time\n\t\t\tif (t/totalTimeMS >= 1) {\n\t\t\t\tthis.stopAnimateSwipe();\n\t\t\t\tthis.completeSwipeTimeout = setTimeout(this.bindSafely(function () {\n\t\t\t\t\tthis.completeSwipe();\n\t\t\t\t}), this.completeSwipeDelayMS);\n\t\t\t}\n\t\t});\n\n\t\tthis.job = animation.requestAnimationFrame(fn);\n\t},\n\n\t/**\n\t* Cancels the active swipe animation.\n\t*\n\t* @private\n\t*/\n\tstopAnimateSwipe: function () {\n\t\tif (this.job) {\n\t\t\tthis.job = animation.cancelAnimationFrame(this.job);\n\t\t}\n\t}\n};\n","/**\n* Contains the declaration for the {@link module:layout/Arranger~Arranger} kind.\n* @module layout/Arranger\n*/\n\nvar\n\tkind = require('enyo/kind'),\n\tutils = require('enyo/utils'),\n\tplatform = require('enyo/platform');\n\nvar\n\tLayout = require('enyo/Layout'),\n\tDom = require('enyo/dom');\n\n/**\n* {@link module:layout/Arranger~Arranger} is an {@link module:enyo/Layout~Layout} that considers one of the\n* controls it lays out as active. The other controls are placed relative to\n* the active control as makes sense for the layout.\n*\n* `layout/Arranger` supports dynamic layouts, meaning it's possible to transition\n* between an arranger's layouts\tvia animation. Typically, arrangers should lay out\n* controls using CSS transforms, since these are optimized for animation. To\n* support this, the controls in an arranger are absolutely positioned, and\n* the Arranger kind has an [accelerated]{@link module:layout/Arranger~Arranger#accelerated} property,\n* which marks controls for CSS compositing. The default setting of `'auto'` ensures\n* that this will occur if enabled by the platform.\n*\n* For more information, see the documentation on\n* [Arrangers]{@linkplain $dev-guide/building-apps/layout/arrangers.html} in the\n* Enyo Developer Guide.\n*\n* @class Arranger\n* @extends module:enyo/Layout~Layout\n* @public\n*/\nvar Arranger = module.exports = kind(\n\t/** @lends module:layout/Arranger~Arranger.prototype */ {\n\n\t/**\n\t* @private\n\t*/\n\tname: 'enyo.Arranger',\n\n\t/**\n\t* @private\n\t*/\n\tkind: Layout,\n\n\t/**\n\t* @private\n\t*/\n\tlayoutClass: 'enyo-arranger',\n\n\t/**\n\t* Flag indicating whether the Arranger should lay out controls using CSS\n\t* compositing. The default setting `('auto')` will mark controls for compositing\n\t* if the platform supports it.\n\t*\n\t* @type {String|Boolean}\n\t* @default 'auto'\n\t* @protected\n\t*/\n\taccelerated: 'auto',\n\n\t/**\n\t* A property of the drag event, used to calculate the amount that a drag will\n\t* move the layout.\n\t*\n\t* @type {String}\n\t* @default 'ddx'\n\t* @private\n\t*/\n\tdragProp: 'ddx',\n\n\t/**\n\t* A property of the drag event, used to calculate the direction of the drag.\n\t*\n\t* @type {String}\n\t* @default 'xDirection'\n\t* @private\n\t*/\n\tdragDirectionProp: 'xDirection',\n\n\t/**\n\t* A property of the drag event, used to calculate whether a drag should occur.\n\t*\n\t* @type {String}\n\t* @default 'horizontal'\n\t* @private\n\t*/\n\tcanDragProp: 'horizontal',\n\n\t/**\n\t* If set to `true`, transitions between non-adjacent arrangements will go\n\t* through the intermediate arrangements. This is useful when direct\n\t* transitions between arrangements would be visually jarring.\n\t*\n\t* @type {Boolean}\n\t* @default false\n\t* @protected\n\t*/\n\tincrementalPoints: false,\n\n\t/**\n\t* Called when removing an arranger (e.g., when switching a Panels control to a\n\t* different `arrangerKind`). Subkinds should implement this function to reset\n\t* whatever properties they've changed on child controls. Note that you **must**\n\t* call the superkind implementation in your subkind's `destroy()` function.\n\t*\n\t* @method\n\t* @private\n\t*/\n\tdestroy: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tvar c$ = this.container.getPanels();\n\t\t\tfor (var i=0, c; (c=c$[i]); i++) {\n\t\t\t\tc._arranger = null;\n\t\t\t}\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* Arranges the given array of `controls` in the layout specified by `index`. When\n\t* implementing this method, rather than applying styling directly to controls, call\n\t* [arrangeControl()]{@link module:layout/Arranger~Arranger#arrangeControl} and pass in an arrangement\n\t* object with styling settings. The styles will then be applied via\n\t* [flowControl()]{@link module:layout/Arranger~Arranger#flowControl}.\n\t*\n\t* @param {module:enyo/Control~Control[]} controls\n\t* @param {Number} index\n\t* @virtual\n\t* @protected\n\t*/\n\tarrange: function (controls, index) {\n\t},\n\n\t/**\n\t* Sizes the controls in the layout. This method is called only at reflow time.\n\t* Note that the sizing operation has been separated from the layout done in\n\t* [arrange()]{@link module:layout/Arranger~Arranger#arrange} because it is expensive and not suitable\n\t* for dynamic layout.\n\t*\n\t* @virtual\n\t* @protected\n\t*/\n\tsize: function () {\n\t},\n\n\t/**\n\t* Called when a layout transition begins. Implement this method to perform\n\t* tasks that should only occur when a transition starts; for example, some\n\t* controls might be shown or hidden. In addition, the `transitionPoints`\n\t* array may be set on the container to dictate the named arrangements\n\t* between which the transition occurs.\n\t*\n\t* @protected\n\t*/\n\tstart: function () {\n\t\tvar f = this.container.fromIndex, t = this.container.toIndex;\n\t\tvar p$ = this.container.transitionPoints = [f];\n\t\t// optionally add a transition point for each index between from and to.\n\t\tif (this.incrementalPoints) {\n\t\t\tvar d = Math.abs(t - f) - 2;\n\t\t\tvar i = f;\n\t\t\twhile (d >= 0) {\n\t\t\t\ti = i + (t < f ? -1 : 1);\n\t\t\t\tp$.push(i);\n\t\t\t\td--;\n\t\t\t}\n\t\t}\n\t\tp$.push(this.container.toIndex);\n\t},\n\n\t/**\n\t* Called when a layout transition completes. Implement this method to\n\t* perform tasks that should only occur when a transition ends; for\n\t* example, some controls might be shown or hidden.\n\t*\n\t* @virtual\n\t* @protected\n\t*/\n\tfinish: function () {\n\t},\n\n\t/**\n\t* Called when dragging the layout, this method returns the difference in\n\t* pixels between the arrangement `a0` for layout setting `i0`\tand\n\t* arrangement `a1` for layout setting `i1`. This data is used to calculate\n\t* the percentage that a drag should move the layout between two active states.\n\t*\n\t* @param {Number} i0 - The initial layout setting.\n\t* @param {Object} a0 - The initial arrangement.\n\t* @param {Number} i1 - The target layout setting.\n\t* @param {Object} a1 - The target arrangement.\n\t* @virtual\n\t* @protected\n\t*/\n\tcalcArrangementDifference: function (i0, a0, i1, a1) {\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tcanDragEvent: function (event) {\n\t\treturn event[this.canDragProp];\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tcalcDragDirection: function (event) {\n\t\treturn event[this.dragDirectionProp];\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tcalcDrag: function (event) {\n\t\treturn event[this.dragProp];\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdrag: function (dp, an, a, bn, b) {\n\t\tvar f = this.measureArrangementDelta(-dp, an, a, bn, b);\n\t\treturn f;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tmeasureArrangementDelta: function (x, i0, a0, i1, a1) {\n\t\tvar d = this.calcArrangementDifference(i0, a0, i1, a1);\n\t\tvar s = d ? x / Math.abs(d) : 0;\n\t\ts = s * (this.container.fromIndex > this.container.toIndex ? -1 : 1);\n\t\treturn s;\n\t},\n\n\t/**\n\t* Arranges the panels, with the panel at `index` being designated as active.\n\t*\n\t* @param  {Number} index - The index of the active panel.\n\t* @private\n\t*/\n\t_arrange: function (index) {\n\t\t// guard against being called before we've been rendered\n\t\tif (!this.containerBounds) {\n\t\t\tthis.reflow();\n\t\t}\n\t\tvar c$ = this.getOrderedControls(index);\n\t\tthis.arrange(c$, index);\n\t},\n\n\t/**\n\t* Arranges `control` according to the specified `arrangement`.\n\t*\n\t* Note that this method doesn't actually modify `control` but rather sets the\n\t* arrangement on a private member of the control to be retrieved by\n\t* {@link module:layout/Panels~Panels}.\n\t*\n\t* @param  {module:enyo/Control~Control} control\n\t* @param  {Object} arrangement\n\t* @private\n\t*/\n\tarrangeControl: function (control, arrangement) {\n\t\tcontrol._arranger = utils.mixin(control._arranger || {}, arrangement);\n\t},\n\n\t/**\n\t* Called before HTML is rendered. Applies CSS to panels to ensure GPU acceleration if\n\t* [accelerated]{@link module:layout/Arranger~Arranger#accelerated} is `true`.\n\t*\n\t* @private\n\t*/\n\tflow: function () {\n\t\tthis.c$ = [].concat(this.container.getPanels());\n\t\tthis.controlsIndex = 0;\n\t\tfor (var i=0, c$=this.container.getPanels(), c; (c=c$[i]); i++) {\n\t\t\tDom.accelerate(c, !c.preventAccelerate && this.accelerated);\n\t\t\tif (platform.safari) {\n\t\t\t\t// On Safari-desktop, sometimes having the panel's direct child set to accelerate isn't sufficient\n\t\t\t\t// this is most often the case with Lists contained inside another control, inside a Panels\n\t\t\t\tvar grands=c.children;\n\t\t\t\tfor (var j=0, kid; (kid=grands[j]); j++) {\n\t\t\t\t\tDom.accelerate(kid, this.accelerated);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* Called during \"rendered\" phase to [size]{@link module:layout/Arranger~Arranger#size} the controls.\n\t*\n\t* @private\n\t*/\n\treflow: function () {\n\t\tvar cn = this.container.hasNode();\n\t\tthis.containerBounds = cn ? {width: cn.clientWidth, height: cn.clientHeight} : {};\n\t\tthis.size();\n\t},\n\n\t/**\n\t* If the {@link module:layout/Panels~Panels} has an arrangement, flows each control according to that\n\t* arrangement.\n\t*\n\t* @private\n\t*/\n\tflowArrangement: function () {\n\t\tvar a = this.container.arrangement;\n\t\tif (a) {\n\t\t\tfor (var i=0, c$=this.container.getPanels(), c; (c=c$[i]) && (a[i]); i++) {\n\t\t\t\tthis.flowControl(c, a[i]);\n\t\t\t}\n\t\t}\n\t},\n\t/**\n\t* Lays out the given `control` according to the settings stored in the\n\t* `arrangement` object. By default, `flowControl()` will apply settings for\n\t* `left`, `top`, and `opacity`. This method should only be implemented to apply\n\t* other settings made via [arrangeControl()]{@link module:layout/Arranger~Arranger#arrangeControl}.\n\t*\n\t* @param {module:enyo/Control~Control} control - The control to be laid out.\n\t* @param {Object} arrangement - An object whose members specify the layout settings.\n\t* @protected\n\t*/\n\tflowControl: function (control, arrangement) {\n\t\tArranger.positionControl(control, arrangement);\n\t\tvar o = arrangement.opacity;\n\t\tif (o != null) {\n\t\t\tArranger.opacifyControl(control, o);\n\t\t}\n\t},\n\n\t/**\n\t* Gets an array of controls arranged in state order.\n\t* note: optimization, dial around a single array.\n\t*\n\t* @param  {Number} index     - The index of the active panel.\n\t* @return {module:enyo/Control~Control[]}   - Ordered array of controls.\n\t* @private\n\t*/\n\tgetOrderedControls: function (index) {\n\t\tvar whole = Math.floor(index);\n\t\tvar a = whole - this.controlsIndex;\n\t\tvar sign = a > 0;\n\t\tvar c$ = this.c$ || [];\n\t\tfor (var i=0; i<Math.abs(a); i++) {\n\t\t\tif (sign) {\n\t\t\t\tc$.push(c$.shift());\n\t\t\t} else {\n\t\t\t\tc$.unshift(c$.pop());\n\t\t\t}\n\t\t}\n\t\tthis.controlsIndex = whole;\n\t\treturn c$;\n\t}\n});\n\n/**\n* Positions a control via transform--`translateX/translateY` if supported,\n* falling back to `left/top` if not.\n*\n* @lends module:layout/Arranger~Arranger\n* @param  {module:enyo/Control~Control} control - The control to position.\n* @param  {Object} bounds        - The new bounds for `control`.\n* @param  {String} unit          - The unit for `bounds` members.\n* @public\n*/\nArranger.positionControl = function (control, bounds, unit) {\n\tunit = unit || 'px';\n\tif (!this.updating) {\n\t\t// IE10 uses setBounds because of control hit caching problems seem in some apps\n\t\tif (Dom.canTransform() && !control.preventTransform && platform.ie !== 10) {\n\t\t\tvar l = bounds.left, t = bounds.top;\n\t\t\tl = utils.isString(l) ? l : l && (l + unit);\n\t\t\tt = utils.isString(t) ? t : t && (t + unit);\n\t\t\tDom.transform(control, {translateX: l || null, translateY: t || null});\n\t\t} else {\n\t\t\t// If a previously positioned control has subsequently been marked with\n\t\t\t// preventTransform, we need to clear out any old translation values.\n\t\t\tif (Dom.canTransform() && control.preventTransform) {\n\t\t\t\tDom.transform(control, {translateX: null, translateY: null});\n\t\t\t}\n\t\t\tcontrol.setBounds(bounds, unit);\n\t\t}\n\t}\n};\n\n/**\n* Sets the opacity value for a given control.\n*\n* @lends module:layout/Arranger~Arranger\n* @param {module:enyo/Control~Control} inControl - The control whose opacity is to be set.\n* @param {Number} inOpacity - The new opacity value for the control.\n* @public\n*/\nArranger.opacifyControl = function (inControl, inOpacity) {\n\t// FIXME: very high/low settings of opacity can cause a control to\n\t// blink so cap this here.\n\tinControl.applyStyle('opacity', inOpacity > 0.99 ? 1 : (inOpacity < 0.01 ? 0 : inOpacity));\n};\n","/**\n* Contains the declaration for the {@link module:layout/CarouselArranger~CarouselArranger} kind.\n* @module layout/CarouselArranger\n*/\n\nvar\n\tkind = require('enyo/kind'),\n\tdom = require('enyo/dom');\n\nvar\n\tArranger = require('./Arranger');\n\n/**\n* {@link module:layout/CarouselArranger~CarouselArranger} is a\n* {@link module:layout/Arranger~Arranger} that displays the active control,\n* along with some number of inactive controls to fill the available space. The\n* active control is positioned on the left side of the container, and the rest\n* of the views are laid out to the right.\n*\n* One of the controls may have `fit: true` set, in which case it will take up\n* any remaining space after all of the other controls have been sized.\n*\n* For best results with CarouselArranger, you should set a minimum width for\n* each control via a CSS style, e.g., `min-width: 25%` or `min-width: 250px`.\n*\n* Transitions between arrangements are handled by sliding the new controls in\n* from the right and sliding the old controls off to the left.\n*\n* For more information, see the documentation on\n* [Arrangers]{@linkplain $dev-guide/building-apps/layout/arrangers.html} in the\n* Enyo Developer Guide.\n*\n* @class CarouselArranger\n* @extends module:layout/Arranger~Arranger\n* @public\n*/\nmodule.exports = kind(\n\t/** @lends module:layout/CarouselArranger~CarouselArranger */ {\n\n\t/**\n\t* @private\n\t*/\n\tname: 'enyo.CarouselArranger',\n\n\t/**\n\t* @private\n\t*/\n\tkind: Arranger,\n\n\t/**\n\t* Calculates the size of each panel. Considers the padding of the container by calling\n\t* {@link module:enyo/dom#calcPaddingExtents} and control margin by calling\n\t* {@link module:enyo/dom#calcMarginExtents}. If the container is larger than the combined sizes of\n\t* the controls, one control may be set to fill the remaining space by setting its `fit`\n\t* property to `true`. If multiple controls have `fit: true` set, the last control to be so\n\t* marked will have precedence.\n\t*\n\t* @protected\n\t*/\n\tsize: function () {\n\t\tvar c$ = this.container.getPanels();\n\t\tvar padding = this.containerPadding = this.container.hasNode() ? dom.calcPaddingExtents(this.container.node) : {};\n\t\tvar pb = this.containerBounds;\n\t\tvar i, e, s, m, c;\n\t\tpb.height -= padding.top + padding.bottom;\n\t\tpb.width -= padding.left + padding.right;\n\t\t// used space\n\t\tvar fit;\n\t\tfor (i=0, s=0; (c=c$[i]); i++) {\n\t\t\tm = dom.calcMarginExtents(c.hasNode());\n\t\t\tc.width = c.getBounds().width;\n\t\t\tc.marginWidth = m.right + m.left;\n\t\t\ts += (c.fit ? 0 : c.width) + c.marginWidth;\n\t\t\tif (c.fit) {\n\t\t\t\tfit = c;\n\t\t\t}\n\t\t}\n\t\tif (fit) {\n\t\t\tvar w = pb.width - s;\n\t\t\tfit.width = w >= 0 ? w : fit.width;\n\t\t}\n\t\tfor (i=0, e=padding.left; (c=c$[i]); i++) {\n\t\t\tc.setBounds({top: padding.top, bottom: padding.bottom, width: c.fit ? c.width : null});\n\t\t}\n\t},\n\n\t/**\n\t* @see {@link module:layout/Arranger~Arranger#arrange}\n\t* @protected\n\t*/\n\tarrange: function (controls, arrangement) {\n\t\tif (this.container.wrap) {\n\t\t\tthis.arrangeWrap(controls, arrangement);\n\t\t} else {\n\t\t\tthis.arrangeNoWrap(controls, arrangement);\n\t\t}\n\t},\n\n\t/**\n\t* A non-wrapping carousel arranges the controls from left to right without regard to the\n\t* ordered array passed via `controls`. `arrangement` will contain the index of the active\n\t* panel.\n\t*\n\t* @private\n\t*/\n\tarrangeNoWrap: function (controls, arrangement) {\n\t\tvar i, aw, cw, c;\n\t\tvar c$ = this.container.getPanels();\n\t\tvar s = this.container.clamp(arrangement);\n\t\tvar nw = this.containerBounds.width;\n\t\t// do we have enough content to fill the width?\n\t\tfor (i=s, cw=0; (c=c$[i]); i++) {\n\t\t\tcw += c.width + c.marginWidth;\n\t\t\tif (cw > nw) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// if content width is less than needed, adjust starting point index and offset\n\t\tvar n = nw - cw;\n\t\tvar o = 0;\n\t\tif (n > 0) {\n\t\t\tfor (i=s-1, aw=0; (c=c$[i]); i--) {\n\t\t\t\taw += c.width + c.marginWidth;\n\t\t\t\tif (n - aw <= 0) {\n\t\t\t\t\to = (n - aw);\n\t\t\t\t\ts = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// arrange starting from needed index with detected offset so we fill space\n\t\tvar w, e;\n\t\tfor (i=0, e=this.containerPadding.left + o; (c=c$[i]); i++) {\n\t\t\tw = c.width + c.marginWidth;\n\t\t\tif (i < s) {\n\t\t\t\tthis.arrangeControl(c, {left: -w});\n\t\t\t} else {\n\t\t\t\tthis.arrangeControl(c, {left: Math.floor(e)});\n\t\t\t\te += w;\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* Arranges `controls` from left to right such that the active panel is always the\n\t* leftmost, with subsequent panels positioned to its right.\n\t*\n\t* @private\n\t*/\n\tarrangeWrap: function (controls, arrangement) {\n\t\tfor (var i=0, e=this.containerPadding.left, c; (c=controls[i]); i++) {\n\t\t\tthis.arrangeControl(c, {left: e});\n\t\t\te += c.width + c.marginWidth;\n\t\t}\n\t},\n\n\t/**\n\t* Calculates the change in `left` position between the two arrangements `a0` and `a1`.\n\t* @protected\n\t*/\n\tcalcArrangementDifference: function (i0, a0, i1, a1) {\n\t\tvar i = Math.abs(i0 % this.c$.length);\n\t\treturn a0[i].left - a1[i].left;\n\t},\n\n\t/**\n\t* Resets the size and position of all panels.\n\t*\n\t* @method\n\t* @private\n\t*/\n\tdestroy: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tvar c$ = this.container.getPanels();\n\t\t\tfor (var i=0, c; (c=c$[i]); i++) {\n\t\t\t\tArranger.positionControl(c, {left: null, top: null});\n\t\t\t\tc.applyStyle('top', null);\n\t\t\t\tc.applyStyle('bottom', null);\n\t\t\t\tc.applyStyle('left', null);\n\t\t\t\tc.applyStyle('width', null);\n\t\t\t}\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t})\n});\n","/**\n* Contains the declaration for the {@link module:layout/CardArranger~CardArranger} kind.\n* @module layout/CardArranger\n*/\n\nvar\n\tkind = require('enyo/kind');\n\nvar\n\tArranger = require('./Arranger');\n\n\n/**\n* {@link module:layout/CardArranger~CardArranger} is a {@link module:layout/Arranger~Arranger}\n* that displays only one active control. The non-active controls are hidden with\n* `setShowing(false)`. Transitions between arrangements are handled by fading\n* from one control to the next.\n*\n* For more information, see the documentation on\n* [Arrangers]{@linkplain $dev-guide/building-apps/layout/arrangers.html} in the\n* Enyo Developer Guide.\n*\n* @class CardArranger\n* @extends module:layout/Arranger~Arranger\n* @public\n*/\nmodule.exports = kind(\n\t/** @lends module:layout/CardArranger~CardArranger.prototype */ {\n\n\t/**\n\t* @private\n\t*/\n\tname: 'enyo.CardArranger',\n\n\t/**\n\t* @private\n\t*/\n\tkind: Arranger,\n\n\t/**\n\t* @private\n\t*/\n\tlayoutClass: 'enyo-arranger enyo-arranger-fit',\n\n\t/**\n\t* @see {@link module:layout/Arranger~Arranger#calcArrangementDifference}\n\t* @protected\n\t*/\n\tcalcArrangementDifference: function (i0, a0, i1, a1) {\n\t\treturn this.containerBounds.width;\n\t},\n\n\t/**\n\t* Applies opacity to the activation and deactivation of panels. Expects the passed-in\n\t* array of controls to be ordered such that the first control in the array is the active\n\t* panel.\n\t*\n\t* @see {@link module:layout/Arranger~Arranger#arrange}\n\t* @protected\n\t*/\n\tarrange: function (controls, arrangement) {\n\t\tfor (var i=0, c, v; (c=controls[i]); i++) {\n\t\t\tv = (i === 0) ? 1 : 0;\n\t\t\tthis.arrangeControl(c, {opacity: v});\n\t\t}\n\t},\n\n\t/**\n\t* Shows the active panel at the start of transition. Also triggers a resize on\n\t* the active panel if it wasn't previously showing.\n\t*\n\t* @see {@link module:layout/Arranger~Arranger#start}\n\t* @method\n\t* @protected\n\t*/\n\tstart: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tsup.apply(this, arguments);\n\t\t\tvar c$ = this.container.getPanels();\n\t\t\tfor (var i=0, c; (c=c$[i]); i++) {\n\t\t\t\tvar wasShowing=c.showing;\n\t\t\t\tc.setShowing(i == this.container.fromIndex || i == (this.container.toIndex));\n\t\t\t\tif (c.showing && !wasShowing) {\n\t\t\t\t\tc.resize();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}),\n\n\t/**\n\t* Hides all non-active panels when the transition completes.\n\t*\n\t* @see {@link module:layout/Arranger~Arranger#finish}\n\t* @method\n\t* @protected\n\t*/\n\tfinish: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tsup.apply(this, arguments);\n\t\t\tvar c$ = this.container.getPanels();\n\t\t\tfor (var i=0, c; (c=c$[i]); i++) {\n\t\t\t\tc.setShowing(i == this.container.toIndex);\n\t\t\t}\n\t\t};\n\t}),\n\n\t/**\n\t* Ensures all panels are showing and visible when the arranger is destroyed.\n\t*\n\t* @method\n\t* @private\n\t*/\n\tdestroy: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tvar c$ = this.container.getPanels();\n\t\t\tfor (var i=0, c; (c=c$[i]); i++) {\n\t\t\t\tArranger.opacifyControl(c, 1);\n\t\t\t\tif (!c.showing) {\n\t\t\t\t\tc.setShowing(true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t})\n});\n","/**\n* Contains the declaration for the {@link module:layout/CollapsingArranger~CollapsingArranger} kind.\n* @module layout/CollapsingArranger\n*/\n\nvar\n\tkind = require('enyo/kind');\n\nvar\n\tCarouselArranger = require('./CarouselArranger');\n\n/**\n* {@link module:layout/CollapsingArranger~CollapsingArranger} is a\n* {@link module:layout/Arranger~Arranger} that displays the active control,\n* along with some number of inactive controls to fill the available space. The\n* active control is positioned on the left side of the container and the rest of\n* the views are laid out to the right. The last control, if visible, will expand\n* to fill whatever space is not taken up by the previous controls.\n*\n* For best results with CollapsingArranger, you should set a minimum width\n* for each control via a CSS style, e.g., `min-width: 25%` or\n* `min-width: 250px`.\n*\n* Transitions between arrangements are handled by sliding the new control\tin\n* from the right and collapsing the old control to the left.\n*\n* For more information, see the documentation on\n* [Arrangers]{@linkplain $dev-guide/building-apps/layout/arrangers.html} in the\n* Enyo Developer Guide.\n*\n* @class CollapsingArranger\n* @extends module:enyo/CarouselArranger~CarouselArranger\n* @public\n*/\nmodule.exports = kind(\n\t/** @lends module:layout/CollapsingArranger~CollapsingArranger.prototype */ {\n\n\t/**\n\t* @private\n\t*/\n\tname: 'enyo.CollapsingArranger',\n\n\t/**\n\t* @private\n\t*/\n\tkind: CarouselArranger,\n\n\t/**\n\t* The distance (in pixels) that each panel should be offset from the left\n\t* when it is selected. This allows controls on the underlying panel to the\n\t* left of the selected one to be partially revealed.\n\t*\n\t* Note that this is imported from the container at construction time.\n\t*\n\t* @public\n\t*/\n\tpeekWidth: 0,\n\n\t/**\n\t* If a panel is added or removed after construction, ensures that any control\n\t* marked to fill remaining space (via its `_fit` member) is reset.\n\t*\n\t* @see {@link module:layout/Arranger~Arranger#size}\n\t* @method\n\t* @protected\n\t*/\n\tsize: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tthis.clearLastSize();\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* Resets any panel marked to fill remaining space that isn't, in fact, the last panel.\n\t*\n\t* @private\n\t*/\n\tclearLastSize: function () {\n\t\tfor (var i=0, c$=this.container.getPanels(), c; (c=c$[i]); i++) {\n\t\t\tif (c._fit && i != c$.length-1) {\n\t\t\t\tc.applyStyle('width', null);\n\t\t\t\tc._fit = null;\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tconstructor: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tsup.apply(this, arguments);\n\t\t\tthis.peekWidth = this.container.peekWidth != null ? this.container.peekWidth : this.peekWidth;\n\t\t};\n\t}),\n\n\t/**\n\t* Arranges controls from left to right starting with first panel. If\n\t* [peekWidth]{@link module:layout/CollapsingArranger~CollapsingArranger#peekWidth} is set, any visible control\n\t* whose index is less than `arrangement` (the active panel's index) will be revealed\n\t* by `peekWidth` pixels.\n\t*\n\t* @see {@link module:layout/Arranger~Arranger#arrange}\n\t* @protected\n\t*/\n\tarrange: function (controls, arrangement) {\n\t\tvar c$ = this.container.getPanels();\n\t\tfor (var i=0, e=this.containerPadding.left, c, n=0; (c=c$[i]); i++) {\n\t\t\tif(c.getShowing()){\n\t\t\t\tthis.arrangeControl(c, {left: e + n * this.peekWidth});\n\t\t\t\tif (i >= arrangement) {\n\t\t\t\t\te += c.width + c.marginWidth - this.peekWidth;\n\t\t\t\t}\n\t\t\t\tn++;\n\t\t\t} else {\n\t\t\t\tthis.arrangeControl(c, {left: e});\n\t\t\t\tif (i >= arrangement) {\n\t\t\t\t\te += c.width + c.marginWidth;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// FIXME: overdragging-ish\n\t\t\tif (i == c$.length - 1 && arrangement < 0) {\n\t\t\t\tthis.arrangeControl(c, {left: e - arrangement});\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* Calculates the change in `left` position of the last panel between the two\n\t* arrangements `a0` and `a1`.\n\t*\n\t* @see {@link module:layout/Arranger~Arranger#calcArrangementDifference}\n\t* @private\n\t*/\n\tcalcArrangementDifference: function (i0, a0, i1, a1) {\n\t\tvar i = this.container.getPanels().length-1;\n\t\treturn Math.abs(a1[i].left - a0[i].left);\n\t},\n\n\t/**\n\t* If the container's `realtimeFit` property is `true`, resizes the last panel to\n\t* fill the space. This ensures that when dragging or animating to the last index,\n\t* there is never blank space to the right of the last panel. If `realtimeFit` is\n\t* falsy, the last panel is not resized until the\n\t* [finish()]{@link module:layout/CollapsingArranger~CollapsingArranger#finish} method is called.\n\t*\n\t* @see {@link module:layout/Arranger~Arranger#flowControls}\n\t* @method\n\t* @private\n\t*/\n\tflowControl: kind.inherit(function (sup) {\n\t\treturn function (inControl, inA) {\n\t\t\tsup.apply(this, arguments);\n\t\t\tif (this.container.realtimeFit) {\n\t\t\t\tvar c$ = this.container.getPanels();\n\t\t\t\tvar l = c$.length-1;\n\t\t\t\tvar last = c$[l];\n\t\t\t\tif (inControl == last) {\n\t\t\t\t\tthis.fitControl(inControl, inA.left);\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\t}),\n\n\t/**\n\t* Ensures that the last panel fills the remaining space when a transition completes.\n\t*\n\t* @see {@link module:layout/Arranger~Arranger#finish}\n\t* @method\n\t* @private\n\t*/\n\tfinish: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tsup.apply(this, arguments);\n\t\t\tif (!this.container.realtimeFit && this.containerBounds) {\n\t\t\t\tvar c$ = this.container.getPanels();\n\t\t\t\tvar a$ = this.container.arrangement;\n\t\t\t\tvar l = c$.length-1;\n\t\t\t\tvar c = c$[l];\n\t\t\t\tthis.fitControl(c, a$[l].left);\n\t\t\t}\n\t\t};\n\t}),\n\n\t/**\n\t* Resizes the given `control` to match the width of the container minus the\n\t* given `offset`.\n\t*\n\t* @param {module:enyo/Control~Control} control - The control that should fit in the remaining space.\n\t* @param {Number} offset        - The left offset of the control with respect to the\n\t* container.\n\t* @private\n\t*/\n\tfitControl: function (control, offset) {\n\t\tcontrol._fit = true;\n\t\tcontrol.applyStyle('width', (this.containerBounds.width - offset) + 'px');\n\t\tcontrol.resize();\n\t}\n});\n","/**\n* Contains the declaration for the {@link module:layout/Panels~Panels} kind.\n* @module layout/Panels\n*/\n\nvar\n\tkind = require('enyo/kind'),\n\tdispatcher = require('enyo/dispatcher'),\n\tdom = require('enyo/dom'),\n\tplatform = require('enyo/platform'),\n\tutils = require('enyo/utils'),\n\tAnimator = require('enyo/Animator');\n\nvar\n\tCardArranger = require('../CardArranger');\n\n/**\n* Fires at the start of a panel transition, when [setIndex()]{@link module:layout/Panels~Panels#setIndex}\n* is called, and also during dragging.\n*\n* @event module:layout/Panels~Panels#onTransitionStart\n* @type {Object}\n* @property {Number} fromIndex - The index of the old panel.\n* @property {Number} toIndex   - The index of the new panel.\n* @public\n*/\n\n/**\n* Fires at the end of a panel transition, when [setIndex()]{@link module:layout/Panels~Panels#setIndex}\n* is called, and also during dragging.\n*\n* @event module:layout/Panels~Panels#onTransitionFinish\n* @type {Object}\n* @property {Number} fromIndex - The index of the old panel.\n* @property {Number} toIndex   - The index of the new panel.\n* @public\n*/\n\n/**\n* The {@link module:layout/Panels~Panels} kind is designed to satisfy a variety of common use cases\n* for application layout. Using `Panels`, controls may be arranged as (among\n* other things) a carousel, a set of collapsing panels, a card stack that fades\n* between panels, or a grid.\n*\n* Any Enyo control may be placed inside a `Panels`, but by convention we\n* refer to each of these controls as a \"panel\". From the set of panels in a\n* `Panels`, one is considered to be active. The active panel is set by index\n* using the [setIndex()]{@link module:layout/Panels~Panels#setIndex} method. The actual layout of\n* the panels typically changes each time the active panel is set, such that the new\n* active panel has the most prominent position.\n*\n* For more information, see the documentation on\n* [Panels]{@linkplain $dev-guide/building-apps/layout/panels.html} in the\n* Enyo Developer Guide.\n*\n* @class Panels\n* @extends module:enyo/Control~Control\n* @ui\n* @public\n*/\nvar Panels = module.exports = kind(\n\t/** @lends module:layout/Panels~Panels.prototype */ {\n\n\t/**\n\t* @private\n\t*/\n\tname: 'enyo.Panels',\n\n\t/**\n\t* @private\n\t*/\n\tclasses: 'enyo-panels',\n\n\t/**\n\t* @lends module:layout/Panels~Panels.prototype\n\t* @private\n\t*/\n\tpublished: {\n\t\t/**\n\t\t* The index of the active panel. The layout of panels is controlled by the\n\t\t* [layoutKind]{@link module:layout/Panels~Panels#layoutKind}, but as a rule, the active panel\n\t\t* is displayed in the most prominent position. For example, in the (default)\n\t\t* {@link module:layout/CardArranger~CardArranger} layout, the active panel is shown and the other\n\t\t* panels are hidden.\n\t\t*\n\t\t* @type {Number}\n\t\t* @default  0\n\t\t* @public\n\t\t*/\n\t\tindex: 0,\n\n\t\t/**\n\t\t* Indicates whether the user may drag between panels.\n\t\t*\n\t\t* @type {Boolean}\n\t\t* @default  true\n\t\t* @public\n\t\t*/\n\t\tdraggable: true,\n\n\t\t/**\n\t\t* Indicates whether the panels animate when transitioning, e.g., when\n\t\t* [setIndex()]{@link module:layout/Panels~Panels#setIndex} is called.\n\t\t*\n\t\t* @type {Boolean}\n\t\t* @default  true\n\t\t* @public\n\t\t*/\n\t\tanimate: true,\n\n\t\t/**\n\t\t* Indicates whether panels \"wrap around\" when moving past the end.\n\t\t* The actual effect depends upon the arranger in use.\n\t\t*\n\t\t* @type {Boolean}\n\t\t* @default  false\n\t\t* @public\n\t\t*/\n\t\twrap: false,\n\n\t\t/**\n\t\t* The arranger kind to be used for dynamic layout.\n\t\t*\n\t\t* @type {String}\n\t\t* @default  'CardArranger'\n\t\t* @public\n\t\t*/\n\t\tarrangerKind: CardArranger,\n\n\t\t/**\n\t\t* By default, each panel will be sized to fit the Panels' width when the\n\t\t* screen size is sufficiently narrow (less than 800px). Set to `false` to\n\t\t* avoid this behavior.\n\t\t*\n\t\t* @type {Boolean}\n\t\t* @default  true\n\t\t* @public\n\t\t*/\n\t\tnarrowFit: true\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tevents: {\n\t\tonTransitionStart: '',\n\t\tonTransitionFinish: ''\n\t},\n\n\t/**\n\t* @private\n\t*/\n\thandlers: {\n\t\tondragstart: 'dragstart',\n\t\tondrag: 'drag',\n\t\tondragfinish: 'dragfinish',\n\t\tonscroll: 'domScroll'\n\t},\n\n\t/**\n\t* @private\n\t*/\n\ttools: [\n\t\t{kind: Animator, onStep: 'step', onEnd: 'animationEnded'}\n\t],\n\n\t/**\n\t* Tracks completion percentage for a transition between two panels.\n\t*\n\t* @private\n\t*/\n\tfraction: 0,\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tcreate: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tthis.transitionPoints = [];\n\t\t\tsup.apply(this, arguments);\n\t\t\tthis.arrangerKindChanged();\n\t\t\tthis.narrowFitChanged();\n\t\t\tthis.indexChanged();\n\t\t};\n\t}),\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\trendered: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tsup.apply(this, arguments);\n\t\t\tdispatcher.makeBubble(this, 'scroll');\n\t\t};\n\t}),\n\n\t/**\n\t* @private\n\t*/\n\tdomScroll: function (sender, event) {\n\t\tif (this.hasNode()) {\n\t\t\tif (this.node.scrollLeft > 0) {\n\t\t\t\t// Reset scrollLeft position\n\t\t\t\tthis.node.scrollLeft = 0;\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tinitComponents: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tthis.createChrome(this.tools);\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* @private\n\t*/\n\tarrangerKindChanged: function () {\n\t\tthis.setLayoutKind(this.arrangerKind);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tnarrowFitChanged: function () {\n\t\tthis.addRemoveClass(Panels.getNarrowClass(), this.narrowFit);\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tdestroy: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\t// When the entire panels is going away, take note so we don't try and do single-panel\n\t\t\t// remove logic such as changing the index and reflowing when each panel is destroyed\n\t\t\tthis.destroying = true;\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* Adjusts the index if the removed control is the active panel and reflows the layout.\n\t*\n\t* @method\n\t* @private\n\t*/\n\tremoveControl: kind.inherit(function (sup) {\n\t\treturn function (control) {\n\t\t\t// Skip extra work during panel destruction.\n\t\t\tif (this.destroying) {\n\t\t\t\treturn sup.apply(this, arguments);\n\t\t\t}\n\t\t\t// adjust index if the current panel is being removed\n\t\t\t// so it's either the previous panel or the first one.\n\t\t\tvar newIndex = -1;\n\t\t\tvar controlIndex = utils.indexOf(control, this.controls);\n\t\t\tif (controlIndex === this.index) {\n\t\t\t\tnewIndex = Math.max(controlIndex - 1, 0);\n\t\t\t}\n\t\t\tsup.apply(this, arguments);\n\t\t\tif (newIndex !== -1 && this.controls.length > 0) {\n\t\t\t\tthis.setIndex(newIndex);\n\t\t\t\tthis.flow();\n\t\t\t\tthis.reflow();\n\t\t\t}\n\t\t};\n\t}),\n\n\t/**\n\t* Designed to be overridden in kinds derived from Panels that have\n\t* non-panel client controls.\n\t*\n\t* @return {Boolean} [description]\n\t* @protected\n\t* @todo  Assume that this should take a control as a parameter.\n\t*/\n\tisPanel: function () {\n\t\treturn true;\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tflow: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tthis.arrangements = [];\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\treflow: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tthis.arrangements = [];\n\t\t\tsup.apply(this, arguments);\n\t\t\tthis.refresh();\n\t\t};\n\t}),\n\n\t/**\n\t* Returns the array of contained panels. Subclasses may override this if they\n\t* don't want the arranger to lay out all of their children.\n\t*\n\t* @return {module:enyo/Control~Control[]} - The array of contained panels.\n\t*/\n\tgetPanels: function () {\n\t\tvar p = this.controlParent || this;\n\t\treturn p.children;\n\t},\n\n\t/**\n\t* Returns a reference to the active panel--i.e., the panel at the specified index.\n\t*\n\t* @return {module:enyo/Control~Control} - The active panel.\n\t*/\n\tgetActive: function () {\n\t\tvar p$ = this.getPanels();\n\t\t//Constrain the index within the array of panels, needed if wrapping is enabled\n\t\tvar index = this.index % p$.length;\n\t\tif (index < 0) {\n\t\t\tindex += p$.length;\n\t\t}\n\t\treturn p$[index];\n\t},\n\n\t/**\n\t* Returns a reference to the {@link module:enyo/Animator~Animator} instance used to\n\t* animate panel transitions. The Panels' animator may be used to set the\n\t* duration of panel transitions, e.g.:\n\t*\n\t* ```\n\t* this.getAnimator().setDuration(1000);\n\t* ```\n\t*\n\t* @return {module:enyo/Animator~Animator} - The {@link module:enyo/Animator~Animator} instance used to animate\n\t* panel transitions.\n\t* @public\n\t*/\n\tgetAnimator: function () {\n\t\treturn this.$.animator;\n\t},\n\n\t/**\n\t* Sets the active panel to the panel specified by the given index.\n\t* Note that if the [animate]{@link module:layout/Panels~Panels#animate} property is set to\n\t* `true`, the active panel will animate into view.\n\t*\n\t* @param {Number} index - The index of the panel to activate.\n\t* @public\n\t*/\n\tsetIndex: function (index) {\n\t\t// override setIndex so that indexChanged is called\n\t\t// whether this.index has actually changed or not. Also, do\n\t\t// index clamping here.\n\t\tvar prevIndex = this.get('index'),\n\t\t\tnewIndex = this.clamp(index);\n\t\tthis.index = newIndex;\n\t\tthis.notifyObservers('index', prevIndex, newIndex);\n\t},\n\n\t/**\n\t* Sets the active panel to the panel specified by the given index.\n\t* The transition to the next panel will be immediate and will not be animated,\n\t* regardless of the value of the [animate]{@link module:layout/Panels~Panels#animate} property.\n\t*\n\t* @param {Number} index - The index of the panel to activate.\n\t* @public\n\t*/\n\tsetIndexDirect: function (index) {\n\t\tif (this.animate) {\n\t\t\tthis.animate = false;\n\t\t\tthis.setIndex(index);\n\t\t\tthis.animate = true;\n\t\t} else {\n\t\t\tthis.setIndex(index);\n\t\t}\n\t},\n\n\t/**\n\t* Selects the named component owned by the Panels and returns its index.\n\t*\n\t* @param  {String} name - The name of the panel to activate.\n\t* @return {Number} The index of the newly activated panel.\n\t* @public\n\t*/\n\tselectPanelByName: function (name) {\n\t\tif (!name) {\n\t\t\treturn;\n\t\t}\n\t\tvar idx = 0;\n\t\tvar panels = this.getPanels();\n\t\tvar len = panels.length;\n\t\tfor (; idx < len; ++idx) {\n\t\t\tif (name === panels[idx].name) {\n\t\t\t\tthis.setIndex(idx);\n\t\t\t\treturn idx;\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* Transitions to the previous panel--i.e., the panel whose index value is one\n\t* less than that of the current active panel.\n\t*\n\t* @public\n\t*/\n\tprevious: function () {\n\t\tvar prevIndex = this.index - 1;\n\t\tif (this.wrap && prevIndex < 0) {\n\t\t\tprevIndex = this.getPanels().length - 1;\n\t\t}\n\t\tthis.setIndex(prevIndex);\n\t},\n\n\t/**\n\t* Transitions to the next panel--i.e., the panel whose index value is one\n\t* greater than that of the current active panel.\n\t*\n\t* @public\n\t*/\n\tnext: function () {\n\t\tvar nextIndex = this.index+1;\n\t\tif (this.wrap && nextIndex >= this.getPanels().length) {\n\t\t\tnextIndex = 0;\n\t\t}\n\t\tthis.setIndex(nextIndex);\n\t},\n\n\t/**\n\t* Ensures that `value` references a valid panel, accounting for\n\t* [wrapping]{@link module:layout/Panels~Panels#wrap}.\n\t*\n\t* @param  {Number} value - The index of a panel.\n\t* @return {Number}       - The valid index of a panel.\n\t* @private\n\t*/\n\tclamp: function (value) {\n\t\tvar l = this.getPanels().length;\n\t\tif (this.wrap) {\n\t\t\t// FIXME: dragging makes assumptions about direction and from->start indexes.\n\t\t\t//return value < 0 ? l : (value > l ? 0 : value);\n\t\t\tvalue %= l;\n\t\t\treturn (value < 0) ? value + l : value;\n\t\t} else {\n\t\t\treturn Math.max(0, Math.min(value, l - 1));\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tindexChanged: function (old) {\n\t\tthis.lastIndex = old;\n\t\tif (!this.dragging && this.$.animator && this.hasNode()) {\n\t\t\tif (this.shouldAnimate()) {\n\t\t\t\t// If we're mid-transition, complete it and indicate we need to transition\n\t\t\t\tif (this.$.animator.isAnimating()) {\n\t\t\t\t\tthis.transitionOnComplete = true;\n\t\t\t\t\tthis.$.animator.complete();\n\t\t\t\t} else {\n\t\t\t\t\tthis.animateTransition();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.directTransition();\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* Returns `true` if the panels should animate in the transition from `fromIndex` to\n\t* `toIndex`. This can be overridden in a {@glossary subkind} for greater customization.\n\t*\n\t* @protected\n\t*/\n\tshouldAnimate: function () {\n\t\treturn this.animate;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tstep: function (sender) {\n\t\tthis.fraction = sender.value;\n\t\tthis.stepTransition();\n\t\treturn true;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tanimationEnded: function (sender, event) {\n\t\tthis.completed();\n\t\treturn true;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tcompleted: function () {\n\t\tthis.finishTransition();\n\n\t\t// Animator.onEnd fires asynchronously so we need an internal flag to indicate we need\n\t\t// to start the next transition when the previous completes\n\t\tif (this.transitionOnComplete) {\n\t\t\tthis.transitionOnComplete = false;\n\t\t\tthis.animateTransition();\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdragstart: function (sender, event) {\n\t\tif (this.draggable && this.layout && this.layout.canDragEvent(event)) {\n\t\t\tevent.preventDefault();\n\t\t\tthis.dragstartTransition(event);\n\t\t\tthis.dragging = true;\n\t\t\tthis.$.animator.stop();\n\t\t\treturn true;\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdrag: function (sender, event) {\n\t\tif (this.dragging) {\n\t\t\tevent.preventDefault();\n\t\t\tthis.dragTransition(event);\n\t\t\treturn true;\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdragfinish: function (sender, event) {\n\t\tif (this.dragging) {\n\t\t\tthis.dragging = false;\n\t\t\tevent.preventTap();\n\t\t\tthis.dragfinishTransition(event);\n\t\t\treturn true;\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdragstartTransition: function (event) {\n\t\tif (!this.$.animator.isAnimating()) {\n\t\t\tvar f = this.fromIndex = this.index;\n\t\t\tthis.toIndex = f - (this.layout ? this.layout.calcDragDirection(event) : 0);\n\t\t} else {\n\t\t\tthis.verifyDragTransition(event);\n\t\t}\n\t\tthis.fromIndex = this.clamp(this.fromIndex);\n\t\tthis.toIndex = this.clamp(this.toIndex);\n\t\t//this.log(this.fromIndex, this.toIndex);\n\t\tthis.fireTransitionStart();\n\t\tif (this.layout) {\n\t\t\tthis.layout.start();\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdragTransition: function (event) {\n\t\t// note: for simplicity we choose to calculate the distance directly between\n\t\t// the first and last transition point.\n\t\tvar d = this.layout ? this.layout.calcDrag(event) : 0;\n\t\tvar t$ = this.transitionPoints, s = t$[0], f = t$[t$.length-1];\n\t\tvar as = this.fetchArrangement(s);\n\t\tvar af = this.fetchArrangement(f);\n\t\tvar dx = this.layout ? this.layout.drag(d, s, as, f, af) : 0;\n\t\tvar dragFail = d && !dx;\n\t\tif (dragFail) {\n\t\t\t//this.log(dx, s, as, f, af);\n\t\t}\n\t\tthis.fraction += dx;\n\t\tvar fr = this.fraction;\n\t\tif (fr > 1 || fr < 0 || dragFail) {\n\t\t\tif (fr > 0 || dragFail) {\n\t\t\t\tthis.dragfinishTransition(event);\n\t\t\t}\n\t\t\tthis.dragstartTransition(event);\n\t\t\tthis.fraction = 0;\n\t\t\t// FIXME: account for lost fraction\n\t\t\t//this.dragTransition(event);\n\t\t}\n\t\tthis.stepTransition();\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdragfinishTransition: function (event) {\n\t\tthis.verifyDragTransition(event);\n\t\tthis.setIndex(this.toIndex);\n\t\t// note: if we're still dragging, then we're at a transition boundary\n\t\t// and should fire the finish event\n\t\tif (this.dragging) {\n\t\t\tthis.fireTransitionFinish();\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tverifyDragTransition: function (event) {\n\t\tvar d = this.layout ? this.layout.calcDragDirection(event) : 0;\n\t\tvar f = Math.min(this.fromIndex, this.toIndex);\n\t\tvar t = Math.max(this.fromIndex, this.toIndex);\n\t\tif (d > 0) {\n\t\t\tvar s = f;\n\t\t\tf = t;\n\t\t\tt = s;\n\t\t}\n\t\tif (f != this.fromIndex) {\n\t\t\tthis.fraction = 1 - this.fraction;\n\t\t}\n\t\t//this.log('old', this.fromIndex, this.toIndex, 'new', f, t);\n\t\tthis.fromIndex = f;\n\t\tthis.toIndex = t;\n\t},\n\n\t/**\n\t* Resets the panels without sending any events.\n\t*\n\t* @private\n\t*/\n\trefresh: function () {\n\t\tif (this.$.animator && this.$.animator.isAnimating()) {\n\t\t\tthis.$.animator.stop();\n\t\t}\n\t\tthis.setupTransition();\n\t\tthis.fraction = 1;\n\t\tthis.stepTransition();\n\t\tthis.transitioning = false;\n\t\tthis.completeTransition();\n\t\tthis.dragging = false;\n\t},\n\n\t/**\n\t* Transitions to the new index without animation\n\t*\n\t* @private\n\t*/\n\tdirectTransition: function () {\n\t\tthis.startTransition();\n\t\tthis.fraction = 1;\n\t\tthis.stepTransition();\n\t\tthis.finishTransition();\n\t},\n\n\t/**\n\t* Animates the transition to the new index\n\t*\n\t* @private\n\t*/\n\tanimateTransition: function () {\n\t\tthis.startTransition();\n\t\tthis.$.animator.play({\n\t\t\tstartValue: this.fraction\n\t\t});\n\t},\n\n\t/**\n\t* Starts the transition between two panels. if a transition is already in progress, this is\n\t* a no-op.\n\t*\n\t* @private\n\t*/\n\tstartTransition: function () {\n\t\tif (!this.transitioning) {\n\t\t\tthis.transitioning = true;\n\t\t\tthis.setupTransition();\n\t\t\tthis.fireTransitionStart();\n\t\t}\n\t},\n\n\t/**\n\t* Sets up transition state\n\t*\n\t* @private\n\t*/\n\tsetupTransition: function () {\n\t\tthis.fromIndex = this.fromIndex != null ? this.fromIndex : this.lastIndex || 0;\n\t\tthis.toIndex = this.toIndex != null ? this.toIndex : this.index;\n\t\tif (this.layout) {\n\t\t\tthis.layout.start();\n\t\t}\n\t},\n\n\t/**\n\t* Completes the transition between two panels.\n\t*\n\t* @private\n\t*/\n\tfinishTransition: function () {\n\t\tthis.transitioning = false;\n\t\tthis.completeTransition(true);\n\t},\n\n\t/**\n\t* Completes the transition by performing any tasks to be run when the transition ends,\n\t* including firing events and clean-up.\n\t*\n\t* @param {Boolean} [fire] - If `true`, will fire the {@link module:layout/Panels~Panels#onTransitionFinish}\n\t*\tevent if deemed necessary.\n\t* @private\n\t*/\n\tcompleteTransition: function (fire) {\n\t\tif (this.layout) {\n\t\t\tthis.layout.finish();\n\t\t}\n\n\t\tif (fire) {\n\t\t\tthis.fireTransitionFinish(true);\n\t\t} else {\n\t\t\tthis.clearTransitionData();\n\t\t}\n\t},\n\n\t/**\n\t* Clears transition-related data.\n\t*\n\t* @private\n\t*/\n\tclearTransitionData: function() {\n\t\tthis.transitionPoints = [];\n\t\tthis.fraction = 0;\n\t\tthis.fromIndex = this.toIndex = null;\n\t},\n\n\t/**\n\t* @fires module:layout/Panels~Panels#onTransitionStart\n\t* @private\n\t*/\n\tfireTransitionStart: function () {\n\t\tvar t = this.startTransitionInfo;\n\t\tif (this.hasNode() && (!t || (t.fromIndex != this.fromIndex || t.toIndex != this.toIndex))) {\n\t\t\tthis.startTransitionInfo = {fromIndex: this.fromIndex, toIndex: this.toIndex};\n\t\t\tthis.doTransitionStart(utils.clone(this.startTransitionInfo));\n\t\t}\n\t},\n\n\t/**\n\t* @fires module:layout/Panels~Panels#onTransitionFinish\n\t* @param {Boolean} [clearData] - If `true`, {@link module:layout/Panels~Panels#clearTransitionData} will be\n\t*\tcalled after recording the values needed for the callback.\n\t* @private\n\t*/\n\tfireTransitionFinish: function (clearData) {\n\t\tvar t = this.finishTransitionInfo,\n\t\t\tfromIndex = t ? t.fromIndex : null,\n\t\t\ttoIndex = t ? t.toIndex : null;\n\t\tif (this.hasNode() && (!t || (fromIndex != this.fromIndex || toIndex != this.toIndex))) {\n\t\t\t\tif (this.transitionOnComplete) {\n\t\t\t\tthis.finishTransitionInfo = {fromIndex: toIndex, toIndex: this.lastIndex};\n\t\t\t\t} else {\n\t\t\t\t\tthis.finishTransitionInfo = {fromIndex: this.lastIndex, toIndex: this.index};\n\t\t\t\t}\n\t\t\tif (clearData) {\n\t\t\t\tthis.clearTransitionData();\n\t\t\t}\n\t\t\t\tthis.doTransitionFinish(utils.clone(this.finishTransitionInfo));\n\t\t} else if (clearData) {\n\t\t\tthis.clearTransitionData();\n\t\t}\n\t},\n\n\t/**\n\t* Interpolates between arrangements as needed.\n\t*\n\t* @private\n\t*/\n\tstepTransition: function () {\n\t\tif (this.hasNode()) {\n\t\t\t// select correct transition points and normalize fraction.\n\t\t\tvar t$ = this.transitionPoints;\n\t\t\tvar r = (this.fraction || 0) * (t$.length-1);\n\t\t\tvar i = Math.floor(r);\n\t\t\tr = r - i;\n\t\t\tvar s = t$[i], f = t$[i+1];\n\t\t\t// get arrangements and lerp between them\n\t\t\tvar s0 = this.fetchArrangement(s);\n\t\t\tvar s1 = this.fetchArrangement(f);\n\t\t\tthis.arrangement = s0 && s1 ? Panels.lerp(s0, s1, r) : (s0 || s1);\n\t\t\tif (this.arrangement && this.layout) {\n\t\t\t\tthis.layout.flowArrangement();\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* Fetches the arrangement at a specified index, initializing it if necessary.\n\t*\n\t* @param  {Number} index - The index of the desired arrangement from `transitionPoints`.\n\t* @return {Object} The desired arrangement object.\n\t* @private\n\t*/\n\tfetchArrangement: function (index) {\n\t\tif ((index != null) && !this.arrangements[index] && this.layout) {\n\t\t\tthis.layout._arrange(index);\n\t\t\tthis.arrangements[index] = this.readArrangement(this.getPanels());\n\t\t}\n\t\treturn this.arrangements[index];\n\t},\n\n\t/**\n\t* Iterates over `panels` and retrieves a copy of each panel's `_arranger`.\n\t*\n\t* @param  {module:enyo/Control~Control[]} panels - The array of panels.\n\t* @return {Object[]}              - The array of arrangement objects.\n\t*/\n\treadArrangement: function (panels) {\n\t\tvar r = [];\n\t\tfor (var i=0, c$=panels, c; (c=c$[i]); i++) {\n\t\t\tr.push(utils.clone(c._arranger));\n\t\t}\n\t\treturn r;\n\t},\n\n\t/**\n\t* @lends module:layout/Panels~Panels\n\t* @private\n\t*/\n\tstatics: {\n\t\t/**\n\t\t* Returns `true` for iOS and Android phone form factors, or when window width\n\t\t* is 800px or less. Approximates work done using media queries in `Panels.css`.\n\t\t*\n\t\t* @return {Boolean} `true` for narrow devices or viewports; otherwise, `false`.\n\t\t* @public\n\t\t*/\n\t\tisScreenNarrow: function () {\n\t\t\tif(Panels.isNarrowDevice()) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn dom.getWindowWidth() <= 800;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t* Returns the class name to apply for narrow fitting. See media queries\n\t\t* in `Panels.css`.\n\t\t*\n\t\t* @return {String} The CSS class name to apply.\n\t\t*/\n\t\tgetNarrowClass: function () {\n\t\t\tif(Panels.isNarrowDevice()) {\n\t\t\t\treturn 'enyo-panels-force-narrow';\n\t\t\t} else {\n\t\t\t\treturn 'enyo-panels-fit-narrow';\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t* Lerps between arrangements.\n\t\t*\n\t\t* @param  {Object[]} a0     - Array of current arrangement objects.\n\t\t* @param  {Object[]} a1     - Array of target arrangement object.\n\t\t* @param  {Number} fraction - The fraction (between 0 and 1) with which to lerp.\n\t\t* @return {Object[]}        - Array of arrangements that is `fraction` between\n\t\t* \t`a0` and `a1`.\n\t\t* @private\n\t\t*/\n\t\tlerp: function (a0, a1, fraction) {\n\t\t\tvar r = [];\n\t\t\tfor (var i=0, k$=utils.keys(a0), k; (k=k$[i]); i++) {\n\t\t\t\tr.push(this.lerpObject(a0[k], a1[k], fraction));\n\t\t\t}\n\t\t\treturn r;\n\t\t},\n\n\t\t/**\n\t\t* Lerps between the values of arrangement objects.\n\t\t*\n\t\t* @param  {Object} a0       - The source arragement.\n\t\t* @param  {Object} a1       - The destination arragement.\n\t\t* @param  {Number} fraction - The fraction (between 0 and 1) with which to lerp.\n\t\t*\n\t\t* @return {Object}          - The lerped arrangement.\n\t\t* @private\n\t\t*/\n\t\tlerpObject: function (a0, a1, fraction) {\n\t\t\tvar b = utils.clone(a0), n, o;\n\t\t\t// a1 might be undefined when deleting panels\n\t\t\tif (a1) {\n\t\t\t\tfor (var i in a0) {\n\t\t\t\t\tn = a0[i];\n\t\t\t\t\to = a1[i];\n\t\t\t\t\tif (n != o) {\n\t\t\t\t\t\tb[i] = n - (n - o) * fraction;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn b;\n\t\t},\n\n\t\t/**\n\t\t* Tests User Agent strings to identify narrow devices.\n\t\t*\n\t\t* @return {Boolean} `true` if the current device is a narrow device;\n\t\t* otherwise, `false`.\n\t\t*/\n\t\tisNarrowDevice: function () {\n\t\t\tvar ua = navigator.userAgent;\n\t\t\tswitch (platform.platformName) {\n\t\t\t\tcase 'ios':\n\t\t\t\t\treturn (/iP(?:hone|od;(?: U;)? CPU) OS (\\d+)/).test(ua);\n\t\t\t\tcase 'android':\n\t\t\t\t\treturn (/Mobile/).test(ua) && (platform.android > 2);\n\t\t\t\tcase 'androidChrome':\n\t\t\t\t\treturn (/Mobile/).test(ua);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n});\n","/**\n* Contains the declaration for the {@link module:layout/FittableLayout~FittableLayout}, {@link module:layout/FittableLayout~FittableColumnsLayout}\n* and {@link module:layout/FittableLayout~FittableRowsLayout} kinds.\n* @module layout/FittableLayout\n*/\n\nvar\n\tkind = require('enyo/kind'),\n\tdom = require('enyo/dom'),\n\tControl = require('enyo/Control'),\n\tLayout = require('enyo/Layout');\n\nvar detector = document.createElement('div'),\n\tflexAvailable =\n\t\t(detector.style.flexBasis !== undefined) ||\n\t\t(detector.style.webkitFlexBasis !== undefined) ||\n\t\t(detector.style.mozFlexBasis !== undefined) ||\n\t\t(detector.style.msFlexBasis !== undefined);\n\n/**\n* {@link module:layout/FittableLayout~FittableLayout} provides the base\n* positioning and boundary logic for the fittable layout strategy. The fittable\n* layout strategy is based on laying out items in either a set of rows or a set\n* of columns, with most of the items having natural size, but one item expanding\n* to fill the remaining space. The item that expands is labeled with the\n* attribute `fit: true`.\n*\n* The subkinds {@link module:layout/FittableLayout~FittableColumnsLayout} and\n* {@link module:layout/FittableLayout~FittableRowsLayout} (or _their_ subkinds)\n* are used for layout rather than `FittableLayout` because they specify\n* properties that the framework expects to be available when laying items out.\n*\n* When available on the platform, you can opt-in to have `FittableLayout` use\n* CSS flexible box (flexbox) to implement fitting behavior on the platform for\n* better performance; Enyo will fall back to JavaScript-based layout on older\n* platforms. Three subtle differences between the flexbox and JavaScript\n* implementations should be noted:\n\n* - When using flexbox, vertical margins (i.e., `margin-top`, `margin-bottom`) will\n* not collapse; when using JavaScript layout, vertical margins will collapse according\n* to static layout rules.\n*\n* - When using flexbox, non-fitting children of the Fittable must not be sized\n* using percentages of the container (even if set to `position: relative`);\n* this is explicitly not supported by the flexbox 2013 spec.\n*\n* - The flexbox-based Fittable implementation will respect multiple children\n* with `fit: true` (the fitting space will be divided equally between them).\n* This is NOT supported by the JavaScript implementation, and you should not rely\n* upon this behavior if you are deploying to platforms without flexbox support.\n*\n* The flexbox implementation was added to Enyo 2.5.0 as an optional performance\n* optimization; to use the optimization, set `useFlex: true` on the Fittable\n* container.  This will cause flexbox to be used when possible.\n*\n* @class FittableLayout\n* @extends module:enyo/Layout~Layout\n* @public\n*/\nvar FittableLayout = module.exports = kind(/** @lends module:layout/FittableLayout~FittableLayout.prototype */{\n\tname: 'enyo.FittableLayout',\n\n\t/**\n\t* @private\n\t*/\n\tkind: Layout,\n\n\t/**\n\t* @private\n\t*/\n\tnoDefer: true,\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tconstructor: function () {\n\t\tLayout.prototype._constructor.apply(this, arguments);\n\n\t\t// Add the force-ltr class if we're in RTL mode, but this control is set explicitly to NOT be in RTL mode.\n\t\tthis.container.addRemoveClass('force-left-to-right', (Control.prototype.rtl && !this.container.get('rtl')) );\n\n\t\t// Flexbox optimization is determined by global flexAvailable and per-instance opt-in useFlex flag\n\t\tthis.useFlex = flexAvailable && (this.container.useFlex === true);\n\t\tif (this.useFlex) {\n\t\t\tthis.container.addClass(this.flexLayoutClass);\n\t\t} else {\n\t\t\tthis.container.addClass(this.fitLayoutClass);\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tcalcFitIndex: function () {\n\t\tvar aChildren = this.container.children,\n\t\t\toChild,\n\t\t\tn;\n\n\t\tfor (n=0; n<aChildren.length; n++) {\n\t\t\toChild = aChildren[n];\n\t\t\tif (oChild.fit && oChild.showing) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tgetFitControl: function () {\n\t\tvar aChildren = this.container.children,\n\t\t\toFitChild = aChildren[this.fitIndex];\n\n\t\tif (!(oFitChild && oFitChild.fit && oFitChild.showing)) {\n\t\t\tthis.fitIndex = this.calcFitIndex();\n\t\t\toFitChild = aChildren[this.fitIndex];\n\t\t}\n\t\treturn oFitChild;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tshouldReverse: function () {\n\t\treturn this.container.rtl && this.orient === 'h';\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tdestroy: function () {\n\t\tLayout.prototype.destroy.apply(this, arguments);\n\t\t\n\t\tif (this.container) {\n\t\t\tthis.container.removeClass(this.useFlex ? this.flexLayoutClass : this.fitLayoutClass);\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tgetFirstChild: function() {\n\t\tvar aChildren = this.getShowingChildren();\n\n\t\tif (this.shouldReverse()) {\n\t\t\treturn aChildren[aChildren.length - 1];\n\t\t} else {\n\t\t\treturn aChildren[0];\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tgetLastChild: function() {\n\t\tvar aChildren = this.getShowingChildren();\n\n\t\tif (this.shouldReverse()) {\n\t\t\treturn aChildren[0];\n\t\t} else {\n\t\t\treturn aChildren[aChildren.length - 1];\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tgetShowingChildren: function() {\n\t\tvar a = [],\n\t\t\tn = 0,\n\t\t\taChildren = this.container.children,\n\t\t\tnLength   = aChildren.length;\n\n\t\tfor (;n<nLength; n++) {\n\t\t\tif (aChildren[n].showing) {\n\t\t\t\ta.push(aChildren[n]);\n\t\t\t}\n\t\t}\n\n\t\treturn a;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\t_reflow: function(sMeasureName, sClienMeasure, sAttrBefore, sAttrAfter) {\n\t\tthis.container.addRemoveClass('enyo-stretch', !this.container.noStretch);\n\t\t\n\t\tvar oFitChild       = this.getFitControl(),\n\t\t\toContainerNode  = this.container.hasNode(),  // Container node\n\t\t\tnTotalSize     = 0,                          // Total container width or height without padding\n\t\t\tnBeforeOffset   = 0,                         // Offset before fit child\n\t\t\tnAfterOffset    = 0,                         // Offset after fit child\n\t\t\toPadding,                                    // Object containing t,b,r,l paddings\n\t\t\toBounds,                                     // Bounds object of fit control\n\t\t\toLastChild,\n\t\t\toFirstChild,\n\t\t\tnFitSize;\n\n\t\tif (!oFitChild || !oContainerNode) { return true; }\n\n\t\toPadding   = dom.calcPaddingExtents(oContainerNode);\n\t\toBounds    = oFitChild.getBounds();\n\t\tnTotalSize = oContainerNode[sClienMeasure] - (oPadding[sAttrBefore] + oPadding[sAttrAfter]);\n\n\t\t// If total size is zero, there's nothing for us to do (and the Control\n\t\t// we're doing layout for is probably hidden). In this case, we\n\t\t// short-circuit and return `true` to signify that we want to reflow\n\t\t// again the next time the Control is shown.\n\t\tif (nTotalSize === 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (this.shouldReverse()) {\n\t\t\toFirstChild  = this.getFirstChild();\n\t\t\tnAfterOffset = nTotalSize - (oBounds[sAttrBefore] + oBounds[sMeasureName]);\n\n\t\t\tvar nMarginBeforeFirstChild = dom.getComputedBoxValue(oFirstChild.hasNode(), 'margin', sAttrBefore) || 0;\n\n\t\t\tif (oFirstChild == oFitChild) {\n\t\t\t\tnBeforeOffset = nMarginBeforeFirstChild;\n\t\t\t} else {\n\t\t\t\tvar oFirstChildBounds      = oFirstChild.getBounds(),\n\t\t\t\t\tnSpaceBeforeFirstChild = oFirstChildBounds[sAttrBefore] - (oPadding[sAttrBefore] || 0);\n\n\t\t\t\tnBeforeOffset = oBounds[sAttrBefore] + nMarginBeforeFirstChild - nSpaceBeforeFirstChild;\n\t\t\t}\n\t\t} else {\n\t\t\toLastChild    = this.getLastChild();\n\t\t\tnBeforeOffset = oBounds[sAttrBefore] - (oPadding[sAttrBefore] || 0);\n\n\t\t\tvar nMarginAfterLastChild = dom.getComputedBoxValue(oLastChild.hasNode(), 'margin', sAttrAfter) || 0;\n\n\t\t\tif (oLastChild == oFitChild) {\n\t\t\t\tnAfterOffset = nMarginAfterLastChild;\n\t\t\t} else {\n\t\t\t\tvar oLastChildBounds = oLastChild.getBounds(),\n\t\t\t\t\tnFitChildEnd     = oBounds[sAttrBefore] + oBounds[sMeasureName],\n\t\t\t\t\tnLastChildEnd    = oLastChildBounds[sAttrBefore] + oLastChildBounds[sMeasureName] +  nMarginAfterLastChild;\n\n\t\t\t\tnAfterOffset = nLastChildEnd - nFitChildEnd;\n\t\t\t}\n\t\t}\n\n\t\tnFitSize = nTotalSize - (nBeforeOffset + nAfterOffset);\n\t\toFitChild.applyStyle(sMeasureName, nFitSize + 'px');\n\t},\n\n\t/**\n\t* Assigns any static layout properties not dependent on changes to the\n\t* rendered component or container sizes, etc.\n\t* \n\t* @public\n\t*/\n\tflow: function() {\n\t\tif (this.useFlex) {\n\t\t\tvar i,\n\t\t\t\tchildren = this.container.children,\n\t\t\t\tchild;\n\t\t\tthis.container.addClass(this.flexLayoutClass);\n\t\t\tthis.container.addRemoveClass('nostretch', this.container.noStretch);\n\t\t\tfor (i=0; i<children.length; i++) {\n\t\t\t\tchild = children[i];\n\t\t\t\tchild.addClass('enyo-flex-item');\n\t\t\t\tchild.addRemoveClass('flex', child.fit);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* Updates the layout to reflect any changes made to the layout container or\n\t* the contained components.\n\t*\n\t* @public\n\t*/\n\treflow: function() {\n\t\tif (!this.useFlex) {\n\t\t\tif (this.orient == 'h') {\n\t\t\t\treturn this._reflow('width', 'clientWidth', 'left', 'right');\n\t\t\t} else {\n\t\t\t\treturn this._reflow('height', 'clientHeight', 'top', 'bottom');\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t* @lends module:layout/FittableLayout~FittableLayout.prototype\n\t*/\n\tstatics: {\n\t\t/**\n\t\t* Indicates whether flexbox optimization can be used.\n\t\t*\n\t\t* @type {Boolean}\n\t\t* @default  false\n\t\t* @private\n\t\t*/\n\t\tflexAvailable: flexAvailable\n\t}\n});\n\n/**\n* {@link module:layout/FittableLayout~FittableColumnsLayout} provides a\n* container in which items are laid out in a set of vertical columns, with most\n* of the items having natural size, but one expanding to fill the remaining\n* space. The one that expands is labeled with the attribute `fit: true`.\n*\n* `FittableColumnsLayout` is meant to be used as a value for the `layoutKind`\n* property of other kinds. `layoutKind` provides a way to add layout behavior in\n* a pluggable fashion while retaining the ability to use a specific base kind.\n*\n* For more information, see the documentation on\n* [Fittables]{@linkplain $dev-guide/building-apps/layout/fittables.html} in the\n* Enyo Developer Guide.\n*\n* @class FittableColumnsLayout\n* @extends module:layout/FittableLayout~FittableLayout\n* @public\n*/\n\n/**\n* The declaration for {@link module:layout/FittableLayout~FittableColumnsLayout}\n*/\nmodule.exports.Columns = kind(/** @lends module:layout/FittableLayout~FittableColumnsLayout.prototype */{\n\tname        : 'enyo.FittableColumnsLayout',\n\tkind        : FittableLayout,\n\torient      : 'h',\n\tfitLayoutClass : 'enyo-fittable-columns-layout',\n\tflexLayoutClass: 'enyo-flex-container columns'\n});\n\n\n/**\n* {@link module:layout/FittableLayout~FittableRowsLayout} provides a container\n* in which items are laid out in a set of horizontal rows, with most of the\n* items having natural size, but one expanding to fill the remaining space. The\n* one that expands is labeled with the attribute `fit: true`.\n*\n* `FittableRowsLayout` is meant to be used as a value for the `layoutKind`\n* property of other kinds. `layoutKind` provides a way to add layout behavior in\n* a pluggable fashion while retaining the ability to use a specific base kind.\n*\n* For more information, see the documentation on\n* [Fittables]{@linkplain $dev-guide/building-apps/layout/fittables.html} in the\n* Enyo Developer Guide.\n*\n* @class FittableRowsLayout\n* @extends module:layout/FittableLayout~FittableLayout\n* @public\n*/\n\n/**\n* The declaration for {@link module:layout/FittableLayout~FittableRowsLayout}\n*/\nmodule.exports.Rows = kind(\n\t/** @lends module:layout/FittableLayout~FittableRowsLayout.prototype */ {\n\n\t/**\n\t* @private\n\t*/\n\tname        : 'enyo.FittableRowsLayout',\n\n\t/**\n\t* @private\n\t*/\n\tkind        : FittableLayout,\n\n\t/**\n\t* Layout CSS class used to fit rows.\n\t*\n\t* @type {String}\n\t* @default 'enyo-fittable-rows-layout'\n\t* @public\n\t*/\n\tfitLayoutClass : 'enyo-fittable-rows-layout',\n\n\t/**\n\t* The orientation of the layout.\n\t*\n\t* @type {String}\n\t* @default 'v'\n\t* @public\n\t*/\n\torient      : 'v',\n\n\t/**\n\t* @private\n\t*/\n\tflexLayoutClass: 'enyo-flex-container rows'\n});\n","/**\n* Contains the declaration for the {@link module:layout/FlyweightRepeater~FlyweightRepeater} kind.\n* @module layout/FlyweightRepeater\n*/\n\nvar\n\tkind = require('enyo/kind'),\n\tdom = require('enyo/dom'),\n\tutils = require('enyo/utils'),\n\tControl = require('enyo/Control'),\n\tHTMLStringDelegate = require('enyo/HTMLStringDelegate'),\n\tSelection = require('enyo/Selection');\n\nvar FlyweightRepeaterDelegate = Object.create(HTMLStringDelegate);\n\nFlyweightRepeaterDelegate.generateInnerHtml = function (control) {\n\tvar h = '';\n\tcontrol.index = null;\n\t// note: can supply a rowOffset\n\t// and indicate if rows should be rendered top down or bottomUp\n\tfor (var i=0, r=0; i<control.count; i++) {\n\t\tr = control.rowOffset + (this.bottomUp ? control.count - i-1 : i);\n\t\tcontrol.setupItem(r);\n\t\tcontrol.$.client.setAttribute('data-enyo-index', r);\n\t\tif (control.orient == 'h') {\n\t\t\tcontrol.$.client.setStyle('display:inline-block;');\n\t\t}\n\t\th += HTMLStringDelegate.generateChildHtml(control);\n\t\tcontrol.$.client.teardownRender();\n\t}\n\treturn h;\n};\n\n/**\n* Fires once per row at render time.\n*\n* @event module:layout/FlyweightRepeater~FlyweightRepeater#onSetupItem\n* @type {Object}\n* @property {Number} index     - The index of the row being rendered.\n* @property {Boolean} selected - `true` if the row is selected; otherwise, `false`.\n* @public\n*/\n\n/**\n* Fires after an individual row has been rendered.\n*\n* @event module:layout/FlyweightRepeater~FlyweightRepeater#onRenderRow\n* @type {Object}\n* @property {Number} rowIndex - The index of the row that was rendered.\n* @public\n*/\n\n/**\n* {@link module:layout/FlyweightRepeater~FlyweightRepeater} is a control that displays a repeating list of\n* rows, suitable for displaying medium-sized lists (up to ~100 items). A\n* flyweight strategy is employed to render one set of row controls, as needed,\n* for as many rows as are contained in the repeater.\n*\n* The FlyweightRepeater's `components` block contains the controls to be used\n* for a single row. This set of controls will be rendered for each row. You\n* may customize row rendering by handling the\n* [onSetupItem]{@link module:layout/FlyweightRepeater~FlyweightRepeater#onSetupItem} event.\n*\n* The controls inside a FlyweightRepeater are non-interactive. This means that\n* calling methods that would normally cause rendering to occur (e.g.,\n* `set('content', <value>)`) will not do so. However, you may force a row to\n* render by calling [renderRow()]{@link module:layout/FlyweightRepeater~FlyweightRepeater#renderRow}.\n*\n* In addition, you may force a row to be temporarily interactive by calling\n* [prepareRow()]{@link module:layout/FlyweightRepeater~FlyweightRepeater#prepareRow}. Call\n* [lockRow()]{@link module:layout/FlyweightRepeater~FlyweightRepeater#lockRow} when the interaction\n* is complete.\n*\n* For more information, see the documentation on\n* [Lists]{@linkplain $dev-guide/building-apps/layout/lists.html} in the\n* Enyo Developer Guide.\n*\n* @class FlyweightRepeater\n* @extends module:enyo/Control~Control\n* @ui\n* @public\n*/\nvar FlyweightRepeater = module.exports = kind(\n\t/** @lends module:layout/FlyweightRepeater~FlyweightRepeater.prototype */ {\n\n\t/**\n\t* @private\n\t*/\n\tname: 'enyo.FlyweightRepeater',\n\n\t/**\n\t* @private\n\t*/\n\tkind: Control,\n\n\t/**\n\t* @lends module:layout/FlyweightRepeater~FlyweightRepeater.prototype\n\t* @private\n\t*/\n\tpublished: {\n\t\t/**\n\t\t * The number of rows to render.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @public\n\t\t */\n\t\tcount: 0,\n\n\t\t/**\n\t\t* If `true`, the selection mechanism is disabled. Tap events are still\n\t\t* sent, but items won't be automatically re-rendered when tapped.\n\t\t*\n\t\t* @type {Boolean}\n\t\t* @default false\n\t\t* @public\n\t\t*/\n\t\tnoSelect: false,\n\n\t\t/**\n\t\t * If `true`, multiple selection is allowed.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @public\n\t\t */\n\t\tmultiSelect: false,\n\n\t\t/**\n\t\t * If `true`, the selected item will toggle.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @public\n\t\t */\n\t\ttoggleSelected: false,\n\n\t\t/**\n\t\t* Used to specify CSS classes for the repeater's wrapper component (client).\n\t\t* Input is identical to that of {@link module:enyo/Control~Control#setClasses}.\n\t\t*\n\t\t* @type {String}\n\t\t* @default ''\n\t\t* @public\n\t\t*/\n\t\tclientClasses: '',\n\n\t\t/**\n\t\t* Used to specify custom styling for the repeater's wrapper component\n\t\t* (client). Input is identical to that of {@link module:enyo/Control~Control#setStyle}.\n\t\t*\n\t\t* @type {String}\n\t\t* @default ''\n\t\t* @public\n\t\t*/\n\t\tclientStyle: '',\n\n\t\t/**\n\t\t* Numerical offset applied to row number during row generation. Allows items\n\t\t* to have natural indices instead of `0`-based ones. This value must be\n\t\t* positive, as row number `-1` is used to represent undefined rows in the\n\t\t* event system.\n\t\t*\n\t\t* @type {Number}\n\t\t* @default 0\n\t\t* @public\n\t\t*/\n\t\trowOffset: 0,\n\n\t\t/**\n\t\t* Direction in which items will be laid out. Valid values are `'v'` for\n\t\t* vertical or `'h'` for horizontal.\n\t\t*\n\t\t* @type {String}\n\t\t* @default 'h'\n\t\t* @public\n\t\t*/\n\t\torient: 'v'\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tevents: {\n\t\tonSetupItem: '',\n\t\tonRenderRow: ''\n\t},\n\n\t/**\n\t* Setting cachePoint: true ensures that events from the repeater's subtree will\n\t* always bubble up through the repeater, allowing the events to be decorated with repeater-\n\t* related metadata and references.\n\t*\n\t* @type {Boolean}\n\t* @default true\n\t* @private\n\t*/\n\tcachePoint: true,\n\n\t/**\n\t* Design-time attribute indicating whether row indices run\n\t* from `0` to [`count`]{@link module:layout/FlyweightRepeater~FlyweightRepeater#count}`-1` `(false)` or\n\t* from [`count`]{@link module:layout/FlyweightRepeater~FlyweightRepeater#count}`-1` to `0` `(true)`.\n\t*\n\t* @type {Boolean}\n\t* @default false\n\t* @public\n\t*/\n\tbottomUp: false,\n\n\t/**\n\t* @private\n\t*/\n\trenderDelegate: FlyweightRepeaterDelegate,\n\n\t/**\n\t* @private\n\t*/\n\tcomponents: [\n\t\t{kind: Selection, onSelect: 'selectDeselect', onDeselect: 'selectDeselect'},\n\t\t{name: 'client'}\n\t],\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tcreate: function () {\n\t\tControl.prototype.create.apply(this, arguments);\n\t\tthis.noSelectChanged();\n\t\tthis.multiSelectChanged();\n\t\tthis.clientClassesChanged();\n\t\tthis.clientStyleChanged();\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tnoSelectChanged: function () {\n\t\tif (this.noSelect) {\n\t\t\tthis.$.selection.clear();\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tmultiSelectChanged: function () {\n\t\tthis.$.selection.setMulti(this.multiSelect);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tclientClassesChanged: function () {\n\t\tthis.$.client.setClasses(this.clientClasses);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tclientStyleChanged: function () {\n\t\tthis.$.client.setStyle(this.clientStyle);\n\t},\n\n\t/**\n\t* @fires module:layout/FlyweightRepeater~FlyweightRepeater#onSetupItem\n\t* @private\n\t*/\n\tsetupItem: function (index) {\n\t\tthis.doSetupItem({index: index, selected: this.isSelected(index)});\n\t},\n\n\t/**\n\t* Renders the list.\n\t*\n\t* @private\n\t*/\n\tgenerateChildHtml: function () {\n\t\treturn this.renderDelegate.generateInnerHtml(this);\n\t},\n\n\t/**\n\t* @todo add link to preview.js\n\t* @private\n\t*/\n\tpreviewDomEvent: function (event) {\n\t\tvar i = this.index = this.rowForEvent(event);\n\t\tevent.rowIndex = event.index = i;\n\t\tevent.flyweight = this;\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tdecorateEvent: function (eventName, event, sender) {\n\t\t// decorate event with index found via dom iff event does not already contain an index.\n\t\tvar i = (event && event.index != null) ? event.index : this.index;\n\t\tif (event && i != null) {\n\t\t\tevent.index = i;\n\t\t\tevent.flyweight = this;\n\t\t}\n\t\tControl.prototype.decorateEvent.apply(this, arguments);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\ttap: function (sender, event) {\n\t\t// ignore taps if selecting is disabled or if they don't target a row\n\t\tif (this.noSelect || event.index === -1) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.toggleSelected) {\n\t\t\tthis.$.selection.toggle(event.index);\n\t\t} else {\n\t\t\tthis.$.selection.select(event.index);\n\t\t}\n\t},\n\n\t/**\n\t* Handler for selection and deselection.\n\t*\n\t* @private\n\t*/\n\tselectDeselect: function (sender, event) {\n\t\tthis.renderRow(event.key);\n\t},\n\n\t/**\n\t* Returns the repeater's [selection]{@link module:enyo/Selection~Selection} component.\n\t*\n\t* @return {module:enyo/Selection~Selection} The repeater's selection component.\n\t* @public\n\t*/\n\tgetSelection: function () {\n\t\treturn this.$.selection;\n\t},\n\n\t/**\n\t* Gets the selection state for the given row index.\n\t*\n\t* @return {Boolean} `true` if the row is currently selected; otherwise, `false`.\n\t* @public\n\t*/\n\tisSelected: function (index) {\n\t\treturn this.getSelection().isSelected(index);\n\t},\n\n\t/**\n\t* Renders the row with the specified index.\n\t*\n\t* @param {Number} index - The index of the row to render.\n\t* @fires module:layout/FlyweightRepeater~FlyweightRepeater#onRenderRow\n\t* @public\n\t*/\n\trenderRow: function (index) {\n\t\t// do nothing if index is out-of-range\n\t\tif (index < this.rowOffset || index >= this.count + this.rowOffset) {\n\t\t\treturn;\n\t\t}\n\t\t//this.index = null;\n\t\t// always call the setupItem callback, as we may rely on the post-render state\n\t\tthis.setupItem(index);\n\t\tvar node = this.fetchRowNode(index);\n\t\tif (node) {\n\t\t\t// hack to keep this working...\n\t\t\tvar delegate = HTMLStringDelegate;\n\n\t\t\tdom.setInnerHtml(node, delegate.generateChildHtml(this.$.client));\n\t\t\tthis.$.client.teardownChildren();\n\t\t\tthis.doRenderRow({rowIndex: index});\n\t\t}\n\t},\n\n\t/**\n\t* Fetches the DOM node for the given row index.\n\t*\n\t* @param {Number} index - The index of the row whose DOM node is to be fetched.\n\t* @return {Node} The DOM node for the specified row.\n\t* @public\n\t*/\n\tfetchRowNode: function (index) {\n\t\tif (this.hasNode()) {\n\t\t\treturn this.node.querySelector('[data-enyo-index=\"' + index + '\"]');\n\t\t}\n\t},\n\n\t/**\n\t* Fetches the row number corresponding to the target of a given event.\n\t*\n\t* @param {Object} event - Event object.\n\t* @return {Number} The index of the row corresponding to the event's target.\n\t* @public\n\t*/\n\trowForEvent: function (event) {\n\t\tif (!this.hasNode()) {\n\t\t\treturn -1;\n\t\t}\n\t\tvar n = event.target;\n\t\twhile (n && n !== this.node) {\n\t\t\tvar i = n.getAttribute && n.getAttribute('data-enyo-index');\n\t\t\tif (i !== null) {\n\t\t\t\treturn Number(i);\n\t\t\t}\n\t\t\tn = n.parentNode;\n\t\t}\n\t\treturn -1;\n\t},\n\n\t/**\n\t* Prepares the specified row such that changes made to the controls inside\n\t* the repeater will be rendered for the row.\n\t*\n\t* @param {Number} index - The index of the row to be prepared.\n\t* @public\n\t*/\n\tprepareRow: function (index) {\n\t\t// do nothing if index is out-of-range\n\t\tif (index < this.rowOffset || index >= this.count + this.rowOffset) {\n\t\t\treturn;\n\t\t}\n\t\t// update row internals to match model\n\t\tthis.setupItem(index);\n\t\tvar n = this.fetchRowNode(index);\n\t\tFlyweightRepeater.claimNode(this.$.client, n);\n\t},\n\n\t/**\n\t* Prevents rendering of changes made to controls inside the repeater.\n\t*\n\t* @public\n\t*/\n\tlockRow: function () {\n\t\tthis.$.client.teardownChildren();\n\t},\n\n\t/**\n\t* Prepares the specified row such that changes made to the controls in the\n\t* repeater will be rendered in the row; then performs the function `func`\n\t* and, finally, locks the row.\n\t*\n\t* @param {Number} index   - The index of the row to be acted upon.\n\t* @param {Function} func  - The function to perform.\n\t* @param {Object} context - The context to which `func` is bound.\n\t* @private\n\t*/\n\tperformOnRow: function (index, func, context) {\n\t\t// do nothing if index is out-of-range\n\t\tif (index < this.rowOffset || index >= this.count + this.rowOffset) {\n\t\t\treturn;\n\t\t}\n\t\tif (func) {\n\t\t\tthis.prepareRow(index);\n\t\t\tutils.call(context || null, func);\n\t\t\tthis.lockRow();\n\t\t}\n\t},\n\n\t/**\n\t* @lends module:layout/FlyweightRepeater~FlyweightRepeater\n\t* @private\n\t*/\n\tstatics: {\n\t\t/**\n\t\t* Associates a flyweight rendered control (`control`) with a\n\t\t* rendering context specified by `node`.\n\t\t*\n\t\t* @param {module:enyo/Control~Control} control - A flyweight-rendered control.\n\t\t* @param {Node} node - The DOM node to be associated with `control`.\n\t\t* @public\n\t\t*/\n\t\tclaimNode: function (control, node) {\n\t\t\tvar n;\n\t\t\tif (node) {\n\t\t\t\tif (node.id !== control.id) {\n\t\t\t\t\tn = node.querySelector('#' + control.id);\n\t\t\t\t} else {\n\t\t\t\t\t// node is already the right node, so just use it\n\t\t\t\t\tn = node;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// FIXME: consider controls generated if we found a node or tag: null, the later so can teardown render\n\t\t\tcontrol.generated = Boolean(n || !control.tag);\n\t\t\tcontrol.node = n;\n\t\t\tif (control.node) {\n\t\t\t\tcontrol.rendered();\n\t\t\t} else {\n\t\t\t\t//enyo.log('Failed to find node for',  control.id, control.generated);\n\t\t\t}\n\t\t\t// update control's class cache based on the node contents\n\t\t\tfor (var i=0, c$=control.children, c; (c=c$[i]); i++) {\n\t\t\t\tthis.claimNode(c, node);\n\t\t\t}\n\t\t}\n\t}\n});\n","/**\n* Contains the declaration for the {@link module:layout/FittableColumns~FittableColumns} kind.\n* @module layout/FittableColumns\n*/\n\nvar\n\tkind = require('enyo/kind');\n\nvar\n\tFittableLayout = require('./FittableLayout'),\n\tFittableColumnsLayout = FittableLayout.Columns;\n\n/**\n* {@link module:layout/FittableColumns~FittableColumns} provides a container in which items are laid out in a\n* set of vertical columns, with most items having natural size, but one\n* expanding to fill the remaining space. The one that expands is labeled with\n* the attribute `fit: true`.\n*\n* For more information, see the documentation on\n* [Fittables]{@linkplain $dev-guide/building-apps/layout/fittables.html} in the\n* Enyo Developer Guide.\n*\n* @class FittableColumns\n* @extends module:enyo/Control~Control\n* @ui\n* @public\n*/\nmodule.exports = kind(/** @lends module:layout/FittableColumns~FittableColumns.prototype */ {\n\n\t/**\n\t* @private\n\t*/\n\tname: 'enyo.FittableColumns',\n\n\t/**\n\t* A {@glossary kind} used to manage the size and placement of child\n\t* [components]{@link module:enyo/Component~Component}.\n\t*\n\t* @type {String}\n\t* @default ''\n\t* @private\n\t*/\n\tlayoutKind: FittableColumnsLayout,\n\n\t/**\n\t* By default, items in columns stretch to fit vertically; set to `true` to\n\t* avoid this behavior.\n\t*\n\t* @type {Boolean}\n\t* @default false\n\t* @public\n\t*/\n\tnoStretch: false\n});\n","/**\n* Contains the declaration for the {@link module:layout/FittableRows~FittableRows} kind.\n* @module layout/FittableRows\n*/\n\nvar\n\tkind = require('enyo/kind')\t;\n\nvar\n\tFittableLayout = require('./FittableLayout'),\n\tFittableRowsLayout = FittableLayout.Rows;\n\n/**\n* {@link module:layout/FittableRows~FittableRows} provides a container in which items are laid out in a\n* set\tof horizontal rows, with most of the items having natural size, but one\n* expanding to fill the remaining space. The one that expands is labeled with\n* the attribute `fit: true`.\n*\n* For more information, see the documentation on\n* [Fittables]{@linkplain $dev-guide/building-apps/layout/fittables.html} in the\n* Enyo Developer Guide.\n*\n* @class FittableRows\n* @extends module:enyo/Control~Control\n* @ui\n* @public\n*/\nmodule.exports = kind(/** @lends module:layout/FittableRows~FittableRows.prototype */{\n\n\t/**\n\t* @private\n\t*/\n\tname: 'enyo.FittableRows',\n\n\t/**\n\t* A {@glossary kind} used to manage the size and placement of child\n\t* [components]{@link module:enyo/Component~Component}.\n\t*\n\t* @type {String}\n\t* @default ''\n\t* @private\n\t*/\n\tlayoutKind: FittableRowsLayout,\n\n\t/**\n\t* By default, items in columns stretch to fit horizontally; set to `true` to\n\t* avoid this behavior.\n\t*\n\t* @type {Boolean}\n\t* @default false\n\t* @public\n\t*/\n\tnoStretch: false\n});\n","/**\n* Contains the declaration for the {@link module:layout/List~List} kind.\n* @module layout/List\n*/\n\nvar\n\tkind = require('enyo/kind'),\n\tutils = require('enyo/utils'),\n\tScroller = require('enyo/Scroller');\n\nvar\n\tFlyweightRepeater = require('layout/FlyweightRepeater');\n\nvar\n\tmethods = require('./methods');\n\n/**\n* A collection of useful metrics about a page.\n*\n* @typedef {Object} module:layout/List~List~PageInfo\n* @property {Number} no       - The page number.\n* @property {Number} size     - The page size.\n* @property {Number} pos      - The page position.\n* @property {Number} startRow - The index of the page's first row.\n* @property {Number} endRow   - The index of the page's last row.\n*/\n\n/**\n* Fires once per row at render time.\n*\n* @event module:layout/List~List#onSetupItem\n* @type {Object}\n* @property {Number} index - The current row index.\n* @public\n*/\n\n/**\n* Fires when reordering starts, to setup reordering components. No additional\n* data is included with this event.\n*\n* @event module:layout/List~List#onSetupReorderComponents\n* @type {Object}\n* @property {Number} index - The current row index.\n* @public\n*/\n\n/**\n* Fires when reordering completes.\n*\n* @event module:layout/List~List#onReorder\n* @type {Object}\n* @property {Number} reorderTo   - The index of the destination row.\n* @property {Number} reorderFrom - The index of the source row.\n* @public\n*/\n\n/**\n* Fires when pinned reordering starts. No additional data is included with\n* this event.\n*\n* @event module:layout/List~List#onSetupPinnedReorderComponents\n* @type {Object}\n* @public\n*/\n\n/**\n* Fires when swiping starts, to set up swipeable components. No additional\n* data is included with this event.\n*\n* @event module:layout/List~List#onSetupSwipeItem\n* @type {Object}\n* @public\n*/\n\n/**\n* @todo onSwipeDrag is never fired\n* @event module:layout/List~List#onSwipeDrag\n* @type {Object}\n* @public\n*/\n\n/**\n* @todo onSwipe is never fired\n* @event module:layout/List~List#onSwipe\n* @type {Object}\n* @public\n*/\n\n/**\n* Fires when a swipe completes.\n*\n* @event module:layout/List~List#onSwipeComplete\n* @type {Object}\n* @property {Number} index      - The index of the row that was swiped.\n* @property {Number} xDirection - The direction of the swipe.\n* @public\n*/\n\n/**\n* {@link module:layout/List~List} is a control that displays a scrolling list of rows,\n* suitable for displaying very large lists. It is optimized such that only a\n* small portion of the list is rendered at a given time. A flyweight pattern\n* is employed, in which controls placed inside the list are created once, but\n* rendered for each list item. For this reason, it's best to use only simple\n* controls in\ta List, such as {@link module:enyo/Control~Control} and {@link module:enyo/Image~Image}.\n*\n* A List's `components` block contains the controls to be used for a single\n* row. This set of controls will be rendered for each row. You may customize\n* row rendering by handling the [onSetupItem]{@link module:layout/List~List#onSetupItem}\n* event.\n*\n* Events fired from within list rows contain the `index` property, which may\n* be used to identify the row from which the event originated.\n*\n* Beginning with Enyo 2.2, lists have built-in support for swipeable and\n* reorderable list items.  Individual list items are swipeable by default; to\n* enable reorderability, set the [reorderable]{@link module:layout/List~List#reorderable}\n* property to `true`.\n*\n* For more information, see the documentation on\n* [Lists]{@linkplain $dev-guide/building-apps/layout/lists.html} in the\n* Enyo Developer Guide.\n*\n* @class List\n* @extends module:enyo/Scroller~Scroller\n* @ui\n* @public\n*/\nmodule.exports = kind(utils.mixin(methods,\n\t/** @lends module:layout/List~List.prototype */ {\n\n\t/**\n\t* @private\n\t*/\n\tname: 'enyo.List',\n\n\t/**\n\t* @private\n\t*/\n\tkind: Scroller,\n\n\t/**\n\t* @private\n\t*/\n\tclasses: 'enyo-list',\n\n\t/**\n\t* @lends module:layout/List~List.prototype\n\t* @private\n\t*/\n\tpublished: {\n\t\t/**\n\t\t* The number of rows contained in the list. Note that as the amount of\n\t\t* list data changes, `setRows()` may be called to adjust the number of\n\t\t* rows. To re-render the list at the current position when the count has\n\t\t* changed, call the [refresh()]{@link module:layout/List~List#refresh} method.  If the\n\t\t* whole data model of the list has changed and you want to redisplay it\n\t\t* from the top, call [reset()]{@link module:layout/List~List#reset}.\n\t\t*\n\t\t* @type {Number}\n\t\t* @default 0\n\t\t* @public\n\t\t*/\n\t\tcount: 0,\n\t\t/**\n\t\t* The number of rows to be shown in a given list page segment. There is\n\t\t* generally no need to adjust this value.\n\t\t*\n\t\t* @type {Number}\n\t\t* @default 50\n\t\t* @public\n\t\t*/\n\t\trowsPerPage: 50,\n\t\t/**\n\t\t* Direction in which the list will be rendered and in which it will be\n\t\t* scrollable. Valid values are `'v'` for vertical or `'h'` for horizontal.\n\t\t*\n\t\t* @type {String}\n\t\t* @default 'v'\n\t\t* @public\n\t\t*/\n\t\torient: 'v',\n\t\t/**\n\t\t* If `true`, the list is rendered such that row `0` is at the bottom of\n\t\t* the viewport and the beginning position of the list is scrolled to the\n\t\t* bottom.\n\t\t*\n\t\t* @type {Boolean}\n\t\t* @default false\n\t\t* @public\n\t\t*/\n\t\tbottomUp: false,\n\t\t/**\n\t\t* If `true`, the selection mechanism is disabled. Tap events are still\n\t\t* sent, but items won't be automatically re-rendered when tapped.\n\t\t*\n\t\t* @type {Boolean}\n\t\t* @default false\n\t\t* @public\n\t\t*/\n\t\tnoSelect: false,\n\n\t\t/**\n\t\t * If `true`, multiple selection is allowed.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @public\n\t\t */\n\t\tmultiSelect: false,\n\n\t\t/**\n\t\t* If `true`, the selected item will toggle.\n\t\t*\n\t\t* @type {Boolean}\n\t\t* @default false\n\t\t* @public\n\t\t*/\n\t\ttoggleSelected: false,\n\n\t\t/**\n\t\t* If `true`, the list will assume that all rows have the same size to\n\t\t* optimize performance.\n\t\t*\n\t\t* @type {Boolean}\n\t\t* @default false\n\t\t* @public\n\t\t*/\n\t\tfixedSize: false,\n\n\t\t/**\n\t\t* If `true`, the list will allow the user to reorder list items.\n\t\t*\n\t\t* @type {Boolean}\n\t\t* @default false\n\t\t* @public\n\t\t*/\n\t\treorderable: false,\n\n\t\t/**\n\t\t* If `true` and `reorderable` is true, a reorderable item will be centered\n\t\t* on finger when created. If `false`, it will be created over the old item\n\t\t* and will then track finger.\n\t\t*\n\t\t* @type {Boolean}\n\t\t* @default true\n\t\t* @public\n\t\t*/\n\t\tcenterReorderContainer: true,\n\n\t\t/**\n\t\t* An array containing components to be shown as a placeholder when\n\t\t* reordering list items.\n\t\t*\n\t\t* @type {module:enyo/Control~Control[]}\n\t\t* @public\n\t\t*/\n\t\treorderComponents: [],\n\n\t\t/**\n\t\t* An array containing components for the pinned version of a row. If not\n\t\t* specified, reordering will not support pinned mode.\n\t\t*\n\t\t* @type {module:enyo/Control~Control[]}\n\t\t* @public\n\t\t*/\n\t\tpinnedReorderComponents: [],\n\n\t\t/**\n\t\t* An array containing any swipeable components that will be used.\n\t\t*\n\t\t* @type {module:enyo/Control~Control[]}\n\t\t* @public\n\t\t*/\n\t\tswipeableComponents: [],\n\n\t\t/**\n\t\t* If `true`, swipe functionality is enabled.\n\t\t*\n\t\t* @type {Boolean}\n\t\t* @default false\n\t\t* @public\n\t\t*/\n\t\tenableSwipe: false,\n\n\t\t/**\n\t\t* If `true`, the list will persist the current swipeable item.\n\t\t*\n\t\t* @type {Boolean}\n\t\t* @default false\n\t\t* @public\n\t\t*/\n\t\tpersistSwipeableItem: false\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tevents: {\n\t\tonSetupItem: '',\n\t\tonSetupReorderComponents: '',\n\t\tonSetupPinnedReorderComponents: '',\n\t\tonReorder: '',\n\t\tonSetupSwipeItem: '',\n\t\tonSwipeDrag: '',\n\t\tonSwipe: '',\n\t\tonSwipeComplete: ''\n\t},\n\n\t/**\n\t* @private\n\t*/\n\thandlers: {\n\t\tonAnimateFinish: 'animateFinish',\n\t\tonRenderRow: 'rowRendered',\n\t\tondragstart: 'dragstart',\n\t\tondrag: 'drag',\n\t\tondragfinish: 'dragfinish',\n\t\tonup: 'up',\n\t\tonholdpulse: 'holdpulse',\n\t\tonflick: 'flick'\n\t},\n\n\t/**\n\t* Average row size (in pixels), calculated as `(page size / number of rows per page)`.\n\t*\n\t* @private\n\t*/\n\trowSize: 0,\n\n\t/**\n\t* @private\n\t*/\n\tlistTools: [\n\t\t{name: 'port', classes: 'enyo-list-port enyo-border-box', components: [\n\t\t\t{name: 'generator', kind: FlyweightRepeater, canGenerate: false, components: [\n\t\t\t\t{tag: null, name: 'client'}\n\t\t\t]},\n\t\t\t{name: 'holdingarea', allowHtml: true, classes: 'enyo-list-holdingarea'},\n\t\t\t{name: 'page0', allowHtml: true, classes: 'enyo-list-page'},\n\t\t\t{name: 'page1', allowHtml: true, classes: 'enyo-list-page'},\n\t\t\t{name: 'placeholder', classes: 'enyo-list-placeholder'},\n\t\t\t{name: 'swipeableComponents', style: 'position:absolute; display:block; top:-1000px; left:0;'}\n\t\t]}\n\t],\n\n\t//* Reorder vars\n\n\t/**\n\t* Length of time, in milliseconds, to wait for to active reordering.\n\t*\n\t* @type {Number}\n\t* @default 600\n\t* @private\n\t*/\n\treorderHoldTimeMS: 600,\n\n\t/**\n\t* Index of the row that we're moving.\n\t*\n\t* @type {Number}\n\t* @default -1\n\t* @private\n\t*/\n\tdraggingRowIndex: -1,\n\n\t/**\n\t* @todo Seems to be cruft ... can't find any references to it in layout.\n\t* @private\n\t*/\n\tinitHoldCounter: 3,\n\n\t/**\n\t* @todo Seems to be cruft ... can't find any references to it in layout.\n\t* @private\n\t*/\n\tholdCounter: 3,\n\n\t/**\n\t* @todo Seems to be cruft ... can't find any references to it in layout.\n\t* @private\n\t*/\n\tholding: false,\n\n\t/**\n\t* Index of the row before which the placeholder item will be shown. If the\n\t* placeholder is at the end of the list, this value will be one larger than\n\t* the row count.\n\t*\n\t* @type {Number}\n\t* @private\n\t*/\n\tplaceholderRowIndex: -1,\n\n\t/**\n\t* Determines scroll height at top/bottom of list where dragging will cause scroll.\n\t*\n\t* @type {Number}\n\t* @default 0.1\n\t* @private\n\t*/\n\tdragToScrollThreshold: 0.1,\n\n\t/**\n\t * Amount to scroll during autoscroll.\n\t *\n\t * @type {Number}\n\t * @default 0\n\t * @private\n\t */\n\tscrollDistance: 0,\n\n\t/**\n\t* Used to determine direction of scrolling during reordering.\n\t*\n\t* @private\n\t*/\n\tprevScrollTop: 0,\n\n\t/**\n\t* Number of milliseconds between scroll events when autoscrolling.\n\t*\n\t* @type {Number}\n\t* @default 20\n\t* @private\n\t*/\n\tautoScrollTimeoutMS: 20,\n\n\t/**\n\t* Holds timeout ID for autoscroll.\n\t*\n\t* @private\n\t*/\n\tautoScrollTimeout: null,\n\n\t/**\n\t* Keep last event Y coordinate to update placeholder position during autoscroll.\n\t*\n\t* @type {Number}\n\t* @private\n\t*/\n\tautoscrollPageY: 0,\n\n\t/**\n\t* Set to `true` to indicate that we're in pinned reordering mode.\n\t*\n\t* @type {Boolean}\n\t* @default false\n\t* @private\n\t*/\n\tpinnedReorderMode: false,\n\n\t/**\n\t* y-coordinate of the original location of the pinned row.\n\t*\n\t* @type {Number}\n\t* @private\n\t*/\n\tinitialPinPosition: -1,\n\n\t/**\n\t* Set to `true` after drag-and-drop has moved the item to reorder at least\n\t* one space. Used to activate pin mode if item is dropped immediately.\n\t*\n\t* @type {Boolean}\n\t* @default false\n\t* @private\n\t*/\n\titemMoved: false,\n\n\t/**\n\t* Tracks the page where the item being dragged is, so we can detect when we\n\t* switch pages and need to adjust rendering.\n\t*\n\t* @type {Number}\n\t* @private\n\t*/\n\tcurrentPageNumber: -1,\n\n\t/**\n\t* Timeout for completing reorder operation.\n\t*\n\t* @private\n\t*/\n\tcompleteReorderTimeout: null,\n\n\t//* Swipeable vars\n\n\t/**\n\t* Index of swiped item.\n\t*\n\t* @type {Number}\n\t* @private\n\t*/\n\tswipeIndex: null,\n\n\t/**\n\t* Direction of swipe.\n\t*\n\t* @type {Number}\n\t* @private\n\t*/\n\tswipeDirection: null,\n\n\t/**\n\t* `true` if a persistent item is currently persisting.\n\t*\n\t* @type {Boolean}\n\t* @default false\n\t* @private\n\t*/\n\tpersistentItemVisible: false,\n\n\t/**\n\t* Side from which the persisting item came.\n\t*\n\t* @type {String}\n\t* @private\n\t*/\n\tpersistentItemOrigin: null,\n\n\t/**\n\t* `true` if swipe was completed.\n\t*\n\t* @type {Boolean}\n\t* @private\n\t*/\n\tswipeComplete: false,\n\n\t/**\n\t* Timeout when waiting for swipe action to complete.\n\t*\n\t* @private\n\t*/\n\tcompleteSwipeTimeout: null,\n\n\t/**\n\t* Length of time (in milliseconds) to wait before completing swipe action.\n\t*\n\t* @type {Number}\n\t* @default 500\n\t* @private\n\t*/\n\tcompleteSwipeDelayMS: 500,\n\n\t/**\n\t* Duration (in milliseconds) of normal swipe animation.\n\t*\n\t* @type {Number}\n\t* @default 200\n\t* @private\n\t*/\n\tnormalSwipeSpeedMS: 200,\n\n\t/**\n\t* Duration (in milliseconds) of fast swipe animation.\n\t*\n\t* @type {Number}\n\t* @default 100\n\t* @private\n\t*/\n\tfastSwipeSpeedMS: 100,\n\n\t/**\n\t* Percentage of a swipe needed to force completion of the swipe.\n\t*\n\t* @type {Number}\n\t* @default 0.2\n\t* @private\n\t*/\n\tpercentageDraggedThreshold: 0.2\n}));\n"]}